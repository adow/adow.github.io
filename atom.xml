<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-cn">
  <id>http://codingnext.com/</id>
  <title>CodingNEXT</title>
  <updated>2017-11-16T02:29:15.664237+00:00</updated>
  <link href="http://codingnext.com/" rel="alternate"/>
  <link href="http://codingnext.com/atom.xml" rel="self"/>
  <generator version="0.3.2">python-feedgen</generator>
  <entry>
    <id>20171110-youcompleteme.html</id>
    <title>20171110 一整天都在和 YouCompleteMe 较劲</title>
    <updated>2017-11-16T02:29:15.664514+00:00</updated>
    <author>
      <name>adow</name>
      <email>reynoldqin@gmail.com</email>
    </author>
    <content type="html">&lt;p&gt;今天本来要写一个 web 服务用来测试订单应用开发。因为要能够被外部访问，我就准备直接在服务器 (一台干净的 GCE 的服务器 CentOS) 上用 Python 写一个简单的应用服务。然后所做的事情经历了如下的步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vim test.py&lt;/code&gt; 写了一个简单的 &lt;code&gt;torando&lt;/code&gt; 应用（输出请求内容），&lt;code&gt;python test.py&lt;/code&gt; 后外面访问正常。&lt;/li&gt;
&lt;li&gt;开始处理对接应用 url 回调的处理，修改 &lt;code&gt;test.py&lt;/code&gt;, 发现缩进行为不对，按下 &lt;code&gt;tab&lt;/code&gt; 居然不是输出4个空格。因为服务器上的 &lt;code&gt;vim&lt;/code&gt; 没有任何的配置。&lt;/li&gt;
&lt;li&gt;从我的 &lt;code&gt;vim&lt;/code&gt; 配置仓库, &lt;code&gt;clone&lt;/code&gt;， 然后连接到 &lt;code&gt;.vimrc&lt;/code&gt; 文件；&lt;/li&gt;
&lt;li&gt;安装 &lt;code&gt;vundle&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;vim&lt;/code&gt; 中使用 &lt;code&gt;vundle&lt;/code&gt; 安装插件, &lt;code&gt;PluginInstall&lt;/code&gt;，提示 &lt;code&gt;LeaderF&lt;/code&gt; 和 &lt;code&gt;YouCompleteMe&lt;/code&gt; 需要更高版本的 &lt;code&gt;vim&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;删除系统内 &lt;code&gt;vim&lt;/code&gt;, 直接编译安装 &lt;code&gt;vim 8&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;编译安装 &lt;code&gt;YouCompleteMe&lt;/code&gt;, 出现错误&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不管是运行 &lt;code&gt;./install.py --clang-completer&lt;/code&gt;,还是编译 &lt;code&gt;ycm_core&lt;/code&gt;, 都是出现一样的编译错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gmake[3]: *** [BoostParts/CMakeFiles/BoostParts.dir/libs/python/src/dict.cpp.o] 错误 4
gmake[2]: *** [BoostParts/CMakeFiles/BoostParts.dir/all] 错误 2
gmake[1]: *** [ycm/CMakeFiles/ycm_core.dir/rule] 错误 2
gmake: *** [ycm_core] 错误 2
ERROR: the build failed.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看了 &lt;code&gt;YouCompleteMe&lt;/code&gt; 的完整安装文档，把所有的工具升级到最新版，还装了 &lt;code&gt;Python3&lt;/code&gt;。还是这个问题，暂时放弃了，不知道是不是 &lt;code&gt;CentOS 7&lt;/code&gt; 或者 &lt;code&gt;vim8&lt;/code&gt; 的问题。我只是想写个 &lt;code&gt;Python&lt;/code&gt;，先用 &lt;code&gt;OmmiComplete&lt;/code&gt;吧。&lt;/p&gt;

&lt;p&gt;所以，代码还没有开始写，一天过去了。&lt;/p&gt;
</content>
    <link href="http://codingnext.com/20171110-youcompleteme.html" rel="alternate"/>
    <published>2017-11-10T00:00:00+08:00</published>
  </entry>
  <entry>
    <id>20171103-ps4-in-box.html</id>
    <title>20171103 PS4 最终还是被收起来了</title>
    <updated>2017-11-16T02:29:15.665229+00:00</updated>
    <author>
      <name>adow</name>
      <email>reynoldqin@gmail.com</email>
    </author>
    <content type="html">&lt;p&gt;今天把 PS4 收起来了，因为一段时间内是没有时间去玩他了。不管是把他放在电视柜上，还是在办公桌上，大部分时间也就是在积灰而已。本来计划每个周末至少有一个晚上来玩游戏，但是实际上很少能做到。有时是因为这周的计划没有完成，所以占用了游戏的时间，有时就是因为懒而已，不想再耗费精力玩游戏。&lt;/p&gt;

&lt;p&gt;在这个主机上我玩的最多的是 PES2016，我每次只使用一个队踢几场热身赛，很少去踢欧冠，其他模式是根本连看都没看过。所以新版的 PES 2018 只是下载了一个试玩版就足够了，唯一的不足在于里面没有 Arsenal，所以我只能使用利物浦随便踢的玩玩。&lt;/p&gt;

&lt;p&gt;入手主机的初衷是想玩几款白金大作。 MGS5 玩到第八章就玩不下去了，动作类游戏对我的操作要求太高了。即使这样，我还是没有吸取教训，又买了神海4，结果连第二章都只玩了一个开头。我最期待的 FF15 买了国行版，虽然评价一般，但是我玩起来还是很喜欢，只是一直停留在第五章。现在他们都和主机一起被收起来了，在我的一些工作完成之前，我都不想再打开他们。&lt;/p&gt;
</content>
    <link href="http://codingnext.com/20171103-ps4-in-box.html" rel="alternate"/>
    <published>2017-11-07T00:00:00+08:00</published>
  </entry>
  <entry>
    <id>you-forget-nsurlcache.html</id>
    <title>被忽视的 NSURLCache</title>
    <updated>2017-11-16T02:29:15.665470+00:00</updated>
    <author>
      <name>adow</name>
      <email>reynoldqin@gmail.com</email>
    </author>
    <content type="html">&lt;p&gt;作为一个 iOS 开发，你一定用过多种图片下载库，大名鼎鼎的 SDWebImage, Swift 下面的 Kingfisher。&lt;/p&gt;

&lt;p&gt;我写此文的目的是想拉你入坑，来构造一个新的轮子，AWebImage 用来实现 iOS App 中的图片下载。&lt;/p&gt;

&lt;p&gt;对于这个新的坑，他是 &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 NSURLCache 和 NSCache 来实现缓存；&lt;/li&gt;
&lt;li&gt;使用 NSURLSession 实现下载；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他没有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有实现自己的缓存系统；&lt;/li&gt;
&lt;li&gt;没有进行图片处理，所以他不能创建缩略图，更不能处理GIF 图片；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于 NSURLSession， 我想不用多说，因为现在大部分的网络请求库都用 NSURLSession 替换原来的 NSURLConnection。但这里的确想说说 NSURLCache。&lt;/p&gt;
&lt;h2&gt;前篇:  NSURLCache&lt;/h2&gt;
&lt;p&gt;现在大多数图片下载库都使用自建的缓存系统，当然我们知道原理是很简单，每个对应的 URL 都在本地保存一个文件，这样重复的 URL 将不再需要访问网络请求，而是从本地读取这个文件，为了更高效的获取图片，我们还会把图片保存在内存中。这样，当开始请求一个图片是，我们先从内存中尝试读取这个文件，如果没有再从磁盘中读取这个文件，如果还是没有，才真正的去网络上请求这个地址。&lt;/p&gt;

&lt;p&gt;保存文件的过程如此简单，但是一旦涉及到如何管理这些缓存文件时，才是真正的问题；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们如何知道缓存的图片什么时候过期（也许他永不过期）；&lt;/li&gt;
&lt;li&gt;我们的磁盘不是无限大的，那些已经很久以前的图片文件该如何删除他们呢？&lt;/li&gt;
&lt;li&gt;我们的内存也不是无限大的，我在内存中如何有些的管理这些缓存文件呢？内存不够的时候该怎么办？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以我们不得不用使用更多的机制来管理这些缓存文件，我们可以有一个文件来记录这些文件的地址和过期时间，我们必须在 App 中实时监控磁盘和内存的使用情况，在适当的时候去移除不必要的图片引用。一旦你开始着手开始这部分的工作，你会发现这其中会非常复杂，到最后可能就直接放弃，不再管他们了。因为我们一开始的目标是减少图片的下载次数，在 App 中更高效的去显示他们，反正这个目的已经达到。&lt;/p&gt;

&lt;p&gt;然而你一旦用上 NSURLCache，这些问题全部不用考虑，你只需要 &lt;strong&gt;设置磁盘和内存的大小&lt;/strong&gt; 就可以了； 使用 NSURLCache 的优势在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;系统自动管理缓存内容，所以你在开发 App 中不用知道该什么时候来删除这些磁盘或者内存中的缓存内容；不用担心系统内存不够的时候该如何有效的清理他们，一旦磁盘或者内存有压力，系统会自动清理他们，当然你也不用关心缓存的时间；&lt;/li&gt;
&lt;li&gt;我感觉最大的优势在于 Cache-Control，因为我们只需要在服务端上根据 Http 协议设置 Cache-Control 的内容就可以告诉 NSURLCache, 这个缓存应该是什么时候过期了，客户端上设置不需要写任何一行代码 （NSURLRequest 的默认缓存策略就是这个）；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;使用 NSURLCache 缓存&lt;/h3&gt;
&lt;p&gt;使用 NSURLCache 的最方便之处在于，他只需要几行代码就可以完成一个稳定的缓存系统；&lt;/p&gt;

&lt;p&gt;首先我们要创建一个 NSURLCache，可以指定用于缓存的磁盘和内存的大小是多少；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let cache = NSURLCache(memoryCapacity: 10 * 1024 * 1024,diskCapacity: 30 * 1024 * 1024,diskPath: "adow.adimageloader.urlcache")&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构造一个 SessionConfiguration, 并使用这个 URLCache&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration()
sessionConfiguration.URLCache = cache&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用这个 sessionConfiguration 来构造一个 NSURLSession&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let session = NSURLSession(configuration: sessionConfiguration, delegate: nil, delegateQueue: self.sessionQueue)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想更简单，可以设置一个全局的 NSURLCache， 这样如果没有特别指定，所有的请求都将使用这个 URLCache。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSCache.setSharedURLCache(cache)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面，就像没有使用缓存一样的去用 session 和 NSURLRequest 去做请求，不用任何改变，比如使用 &lt;code&gt;dataTaskWithRequest&lt;/code&gt; 来请求，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.task = session.dataTaskWithRequest(request) { (data, response, error) in
        if let error = error {
            NSLog("error:%&amp;#64;", error.domain)
        }
        ...
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当这个 NSURLRequest 命中缓存的时候， &lt;code&gt;dataTaskWithRequest&lt;/code&gt; 将不会发起真正的网络请求，而是从缓存中获取内容，我们也不用关心这个缓存到底来自磁盘还是内存。&lt;/p&gt;
&lt;h3&gt;CachePolicy&lt;/h3&gt;
&lt;p&gt;使用 NSURLCache 的最大好处在于可以通过服务器控制 Cache-Control 来管理本地缓存的策略，另外也可以指定另外的几种策略；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NSURLRequestReloadIgnoringLocalCacheData： 忽略缓存，必须从远程地址下载；&lt;/li&gt;
&lt;li&gt;NSURLRequestReturnCacheDataElseLoad：只要本地有缓存就使用本地的缓存（不管过期时间），只有本地没有缓存的时候才使用远程地址下载；&lt;/li&gt;
&lt;li&gt;NSURLRequestReturnCacheDataDontLoad：只从本地缓存获取内容，如果本地没有的话，也不会去远程地址下载（也就是离线模式）；&lt;/li&gt;
&lt;li&gt;NSURLRequestUseProtocolCachePolicy：默认缓存策略；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;设置 CachePolicy 有两个地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以为每个 NSURLRequest 设置单个请求的 &lt;code&gt;cachePolicy&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;也可以通过 NSURLSessionConfiguration 设置 &lt;code&gt;cachePolicy&lt;/code&gt; 来实现 &lt;code&gt;NSURLSession&lt;/code&gt; 下所有的请求都使用同样的缓存策略；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Cache-Control&lt;/h3&gt;
&lt;p&gt;对于最常用的 NSURLRequestUseProtocolCachePolicy， 我们需要有两个注意的地方，即使当一个请求在本地存在缓存的情况下，如果这个请求需要重新验证 （Revalidation),那系统还是会发起一个 HEAD 请求到服务器上去确定内容是否已经被修改过，如果修改的话还是会重新下载；如果缓存内容不需要验证，那系统只需要确定缓存时间是不是已经过期就可以了；&lt;/p&gt;

&lt;p&gt;在开发中，我们只需要在服务端为每个图片资源设置 &lt;code&gt;Cache-Control&lt;/code&gt; 响应头，比如下面的地址&lt;/p&gt;

&lt;p&gt;&lt;a href="http://7vihfk.com1.z0.glb.clouddn.com/photo-1457369804613-52c61a468e7d.jpeg" title=""&gt;http://7vihfk.com1.z0.glb.clouddn.com/photo-1457369804613-52c61a468e7d.jpeg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://7vihfk.com1.z0.glb.clouddn.com/cache-control.png" alt="cache-control.png"&gt;&lt;/p&gt;

&lt;p&gt;的 Response Header 中有字段: &lt;code&gt;Cache-Control:public, max-age=31536000&lt;/code&gt;, 这样就可以确定这个资源的缓存时间。 但事实上，在 App 的开发过程中，我们不需要关心这个的，唯一要做的就是告诉服务端开发的人员务必在静态资源中输出正确的的 &lt;code&gt;Header&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;除了 &lt;code&gt;Cache-Control&lt;/code&gt; ，还有两个字段可以用来控制缓存:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Last-Modified&lt;/code&gt;  这个头的值表明所请求的资源上次修改的时间；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Etag&lt;/code&gt;  这是 “entity tag” 的缩写，它是一个表示所请求资源的内容的标识符。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于 NSURLCache 的更多使用（比如定制缓存），可以参考 : &lt;a href="http://nshipster.cn/nsurlcache/" title=""&gt;http://nshipster.cn/nsurlcache/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但是使用 NSURLCache 的过程中还是会有几个坑需要注意的: &lt;a href="http://www.codingnext.com/nsurlcache.html" title=""&gt;说说 NSURLCache 中的那些坑&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;后篇: 实现 AWebImage&lt;/h2&gt;
&lt;p&gt;介绍完 NSURLCache，我们可以开始挖坑来实现一个自己的图片缓存系统了，&lt;code&gt;AWebImage&lt;/code&gt;, 他包含两个部分；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AWebImage: 包含了 &lt;code&gt;AWImageLoader&lt;/code&gt; 对象中真正的图片下载方法；&lt;/li&gt;
&lt;li&gt;UIImageView+AWebImage： UIImageView 的 extension, 毕竟大部分时候我们是直接在 UIImageView 上面显示下载的图片的；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，我还写了一个 Demo, 用来显示这个功能， 这个 App 调用了 &lt;code&gt;500px.com&lt;/code&gt; 的编辑选推图片列表的接口，我们将他们显示在一个 &lt;code&gt;UICollectionView&lt;/code&gt; 上，点击的时候还会看到这个作品的详细大图；&lt;/p&gt;

&lt;p&gt;&lt;img src="http://7vihfk.com1.z0.glb.clouddn.com/500px-list.png" alt="500px-list.png"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://7vihfk.com1.z0.glb.clouddn.com/500px-detail.png" alt="500px-detail.png"&gt;&lt;/p&gt;
&lt;h3&gt;构建 AWebImage&lt;/h3&gt;
&lt;p&gt;我们实际使用的是一个 &lt;code&gt;AWImageLoader&lt;/code&gt;, 调用其中的 &lt;code&gt;func downloadImage(url:NSURL, callback : AWImageLoaderCallback)&lt;/code&gt; 来获取网络图片内容（或者来自本地缓存）。&lt;/p&gt;

&lt;p&gt;网络访问依靠 NSURLSession， 使用基于 Block 的接口可以很快就写出一个网络请求操作，但是在这之前我们需要考虑一下 NSURLSession 需要使用哪些东西呢；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个用于网络请求的队列 (NSOperationQueue);&lt;/li&gt;
&lt;li&gt;一个所有图片请求共享的缓存 （NSURLCache）&lt;/li&gt;
&lt;li&gt;确定的缓存策略，这里使用默认的缓存策略就好；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上这些东西只需要一个共享的 NSURLSession 就可以了，所有的请求都使用这个 session 发出；所以我们可以构造一个单独的唯一实例的 NSURLSession （一个全局变量）, 然后所有的 &lt;code&gt;AWImageLoader&lt;/code&gt; 都使用相同的 &lt;code&gt;session&lt;/code&gt;; &lt;/p&gt;

&lt;p&gt;但是我们还需要一些其他的大家共享的东西&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;回调函数列表；&lt;/li&gt;
&lt;li&gt;快速缓存；&lt;/li&gt;
&lt;li&gt;其他的异步操作共享队列；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;回调函数&lt;/h4&gt;
&lt;p&gt;由于网络下载图片是一个异步的过程，所以我们需要一个回调函数，在这里的类型是 &lt;code&gt;AWImageLoaderCallback&lt;/code&gt;, 他实际上就是 &lt;code&gt;(UIImage,NSURL) -&gt; ()&lt;/code&gt; 而已，所以在得到图片内容后，我们会得到 &lt;code&gt;UIImage&lt;/code&gt; 和 &lt;code&gt;NSURL&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;有时在一个界面中有两个 UIImageView 显示了同样的图片地址，这时我们不需要发出两次请求，只需要在获取图片内容后分别调用他们的回调函数去显示图片就好了，所以我们对每个 Url 请求，都可能会存在多个回调函数，这种情况在 &lt;code&gt;UITableView&lt;/code&gt; 和 &lt;code&gt;UICollectionView&lt;/code&gt; 中很常见，因为在滚动的过程中，由于 &lt;code&gt;Cell Reuse&lt;/code&gt; 的存在，很多内容会被重复加载；&lt;/p&gt;

&lt;p&gt;所以我们建立一个 &lt;code&gt;fetchList:[String:AWImageLoaderCallbackList]&lt;/code&gt;, 也就是说，针对每一个 url, 都会可能存在一个对应的回调函数列表；当一个请求完成时，会取得对应的回调函数列表并依次调用，然后再将这个 url 对应的回调列表清除；&lt;/p&gt;

&lt;p&gt;但是，由于请求都会在异步线程中完成，这个回调函数队列可能在多个线程中操作，所以我们不得不做一些锁处理，在添加和删除回调函数的时候进行 Lock, 这里使用的是  &lt;code&gt;dispatch_barrier_sync&lt;/code&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// 添加一个 url 的回调函数，如果这个 url 已经在任务中了，只需要增加回调函数，并返回 true, 通知外部不需要重新发起任务
    func addFetch(key:String, callback:AWImageLoaderCallback) -&amp;gt; Bool {
        var skip = false
        let f_list = fetchList[key]
        if f_list != nil {
            skip = true
        }
        dispatch_barrier_sync(fetchListOperationQueue) {
            if var f_list = f_list {
                f_list.append(callback)
                self.fetchList[key] = f_list
            }
            else {
                self.fetchList[key] = [callback,]
            }
        }
        return skip

    }
    /// 删除一个地址的全部回调函数
    func removeFetch(key:String) {
        dispatch_barrier_sync(fetchListOperationQueue) {
            self.fetchList.removeValueForKey(key)
        }
    }
    /// 清理所有地址的回调函数
    func clearFetch() {
        dispatch_barrier_async(fetchListOperationQueue) {
            self.fetchList.removeAll()
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;快速缓存&lt;/h4&gt;
&lt;p&gt;既然  NSURLCache 已经同时使用内存缓存和磁盘缓存了，我们为什么还需要另一个快速缓存呢？&lt;/p&gt;

&lt;p&gt;因为所有 NSURLCache 中对请求的缓存都获取的是 &lt;code&gt;NSData&lt;/code&gt;，所以每次获取内容和还是要将他构造成为 &lt;code&gt;UIImage&lt;/code&gt;, 而在系统中 &lt;code&gt;+ (UIImage * _Nullable)imageWithData:(NSData * _Nonnull)data&lt;/code&gt; 是不会缓存图片的，所以会导致重复创建 &lt;code&gt;UIImage&lt;/code&gt;。另一个原因是，从 NSURLCache 中获取到内容也是一个异步的过程。如果我们把构造好的图片都存入一个单独的内存缓存，那每次下载图片前只要先从这个快速缓存中获取一次内容就可以了（而且也不用异步完成,这在用于显示 UICollectionViewCell, UITableViewCell 中的图片非常重要)，如果没有再继续从 &lt;code&gt;NSURLCache&lt;/code&gt; 或者源站地址下载；&lt;/p&gt;

&lt;p&gt;作为这个快速缓存，&lt;code&gt;NSCache&lt;/code&gt; 是最适合的，他同样会在系统内存又压力时自动清理内容，类似 NSMutableDictionary， 但是他更高效和快速，不会拷贝对象，而且在任意线程中操作都是安全的。使用 NSCache 非常简单，只需要指定使用内存的大小就好了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fastCache = NSCache()
fastCache.totalCostLimit = 30 * 1024 * 1024&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;AWImageLoader 和 AWImageLoaderManager&lt;/h4&gt;
&lt;p&gt;我们把所有共享的东西都通过 &lt;code&gt;AWImageLoaderManager&lt;/code&gt; 来管理，操作队列，NSURLCache， NSCache，回调队列，共享 Session 等, 并作为一个单例；&lt;/p&gt;

&lt;p&gt;而每个下载任务都通过一个 AWImageLoader 发起，他从 &lt;code&gt;AWImageLoaderManager&lt;/code&gt; 获取所有共享的内容 (以及一个共享的 session)。其实我们完全可以把 AWImageLoader 和 AWImageLoaderManager 合并在一起形成一个单例对象。分开他是想在 &lt;code&gt;AWImageLoader&lt;/code&gt; 对象中持有这个请求任务，以便于后面管理（取消）。由于每个任务都会创建 &lt;code&gt;AWImageLoader&lt;/code&gt;，因此将重复的内容分离出来通过一个单例的 &lt;code&gt;AWImageLoaderManager&lt;/code&gt; 来为所有的任务都共享，在外部来看 &lt;code&gt;AWImageLoaderManager&lt;/code&gt; 是不需要知道，只要调用 &lt;code&gt;AWImageLoader&lt;/code&gt; 的方法就可以了；&lt;/p&gt;

&lt;p&gt;下面是 &lt;code&gt;AWImageLoader&lt;/code&gt; 中实际获取图片的代码（先从 fastCache （NSCache），再从 URLCache 或者真正的网络下载，我们不需要自己去从 URLCache 中获取缓存内容，这部分是 NSURLSession 来完成的）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func downloadImage(url:NSURL, callback : AWImageLoaderCallback){
        /// 从 fastCache(NSCache) 获取到以及构造好的图片，直接在当前线程返回
        if let cached_image = self.imageFromFastCache(url) {
            callback(cached_image, url)
            return
        }
        let fetch_key = url.absoluteString
        /// 用来将图片返回到所有的回调函数
        let f_callback = {
            (image:UIImage) -&amp;gt; () in
            if let f_list = AWImageLoaderManager.sharedManager.readFetch(fetch_key) {
                AWImageLoaderManager.sharedManager.removeFetch(fetch_key)
                dispatch_async(dispatch_get_main_queue(), {
                    f_list.forEach({ (f) in
                        f(image,url)
                    })
                })
            }
        }
        /// origin
        /// addFetch 会返回这个请求是不是已经在列表中了，如果有的话，那就不用再次发出请求了，只需要为他添加一个回调函数就可以了
        let skip = AWImageLoaderManager.sharedManager.addFetch(fetch_key, callback: callback)
        if skip {
//            NSLog("skip")
            return
        }
        /// request
        let session = AWImageLoaderManager.sharedManager.defaultSession
        let request = NSURLRequest(URL: url)
        self.task = session.dataTaskWithRequest(request) { (data, response, error) in
            if let error = error {
                NSLog("error:%&amp;#64;", error.domain)
            }
            /// no data
            guard let _data = data else {
                NSLog("no image:%&amp;#64;", url.absoluteString)
                f_callback(emptyImage)
                return
            }
            dispatch_async(AWImageLoaderManager.sharedManager.imageDecodeQueue, {
//                NSLog("origin:%&amp;#64;", url.absoluteString)
                let image = UIImage(data: _data) ?? emptyImage
                AWImageLoaderManager.sharedManager.fastCache.setObject(image, forKey: fetch_key) /// 存入 fastCache
                f_callback(image)
                return
            })
        }
        self.task?.resume()
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;UIImageView + AWebImage&lt;/h3&gt;
&lt;p&gt;就如前面所说，大部分情况下，我们都是在 UIImageView 中显示下载的图像，所以为 UIImageView 建立一个扩展，用来下载和显示网络图像是最自然的方法。这里有一个 UIImageView + AWebImage，实际调用的时候是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;imageView.aw_downloadImageURL(photo.imageURL, showLoading: true, completionBlock: { (image, url) in

       })&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实我们只是调用 &lt;code&gt;AWImageLoader&lt;/code&gt; 的 &lt;code&gt;func downloadImage(url:NSURL, callback : AWImageLoaderCallback)&lt;/code&gt; 方法而已，非常简单。&lt;/p&gt;

&lt;p&gt;但是考虑到 UIImageView 显示的图片可能不是固定的，比如在 UITableViewCell, UICollectionViewCell 中，由于 &lt;code&gt;reuse&lt;/code&gt; 的时候会在同一个 &lt;code&gt;UIImageView&lt;/code&gt; 上显示来自不同位置的图片，而获取图片在很多情况下又是在不可预知顺序的异步方法中，所以很有可能最后显示在屏幕上的并不是当前想要的图片了。有两种解决的办法:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开始获取图片的时候，会取消这个 &lt;code&gt;UIImageView&lt;/code&gt; 之前的图片任务；&lt;/li&gt;
&lt;li&gt;为每个 &lt;code&gt;UIImageView&lt;/code&gt; 存储一个当前任务的下载地址，获取到图片后，在显示之前先判断一下这次回调图片的地址和保存在 &lt;code&gt;UIImageView&lt;/code&gt; 中的地址是不是相同，如果不同的话，说明实际显示的图片已经换掉了，那就不用显示这张图片了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里使用第二种方案，在 &lt;code&gt;UIImageView&lt;/code&gt; 新增一个属性 &lt;code&gt;aw_image_url&lt;/code&gt; 用来存储当前任务的地址，由于 &lt;code&gt;extension&lt;/code&gt; 中不能增加存储属性，所以只能依靠 &lt;code&gt;Associated Object&lt;/code&gt; 来实现:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private var imageUrlKey : Void?

/// 在 extension UIImageView 中增加
/// 下载的 imageurl
var aw_image_url : NSURL? {
    get{
        return objc_getAssociatedObject(self, &amp;amp;imageUrlKey) as? NSURL
    }
    set {
        objc_setAssociatedObject(self, &amp;amp;imageUrlKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当开始获取图片任务时，首先记录一下这个任务的 url, 并在任务的回调函数中检查这个地址是不是有改变, 所以整个 &lt;code&gt;UIImageView.aw_downloadImageURL&lt;/code&gt; 的过程如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func aw_downloadImageURL(url:NSURL,
                               showLoading:Bool,
                               completionBlock:AWImageLoaderCallback){
    /// 先设置要下载的图片地址
    self.aw_image_url = url
    if showLoading {
        self.aw_showLoading()
    }
    let loader = AWImageLoader()
    loader.downloadImage(url) { [weak self](image, url) in
        if showLoading {
            self?.aw_hideLoading()
        }
        guard let _self = self, let _aw_image_url = _self.aw_image_url else {
            NSLog("no imageView")
            return
        }
        /// 校验一下现在是否还需要显示这个地址的图片
        if _aw_image_url.absoluteString != url.absoluteString {
            NSLog("url not match:%&amp;#64;,%&amp;#64;", _aw_image_url,url)
        }
        else{
            self?.aw_setImage(image)
            completionBlock(image,url)
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;在 NSDefaultRunLoopMode 开始下载图片；&lt;/h3&gt;
&lt;p&gt;如果在 UICollectionView 中使用 AWebImage 进行下载，他会在任何 &lt;code&gt;RunLoop&lt;/code&gt; 模式中开始处理，但是有的时候这样做的确是在浪费，因为滚动中很多下载实际被替换掉了，我们最好在滚动结束后才开始真正的图片下载。&lt;/p&gt;

&lt;p&gt;如果在 &lt;code&gt;NSDefaultRunLoopMode&lt;/code&gt; 中开始下载过程，只有滚动结束时候才会真正开始，下载的代码被延时提交了。但是，因为 cell reuse 的时候会清理之前显示的图片，所以实际上在滚动的时候，没有任何图片会显示出来。这时候 fastCache 会体现作用，如果能从 fastCache 中获取内容，那就直接显示在 cell 中（不用等待到滚动结束后开始），如果 fastCache 中没有图片，那只能延时开始下载。&lt;/p&gt;

&lt;p&gt;但是这又会引发另一个问题，在快速滚动中，开始可能下载的任务因为在滚动中被延时，但是紧接着这个cell因为被 &lt;code&gt;reuse&lt;/code&gt; 而这时他又在另一个位置中从 fastCache 中获取了图片并显示了（恰好这个位置的图片存在于 fastCache 中)，而之前的延时任务在后面又被触发了，他会在稍后返回，这时会替换之前从 fastCache 中获取的图片，这时会看到 &lt;code&gt;Cell&lt;/code&gt; 中显示图片变化了一下，而且显示的并不是现在这个位置需要的图片。需要注意的时候这种情况下是无法通过保存的 &lt;code&gt;aw_image_url&lt;/code&gt; 匹配来忽略图片显示的，因为他的代码是在后面执行的（延时提交了），所以地址已经被更新了。解决的办法是引入 &lt;code&gt;aw_image_set&lt;/code&gt; 作为判断，在任务真正开始前，如果 &lt;code&gt;aw_image_set&lt;/code&gt; 被设置了，就不用开始这个任务了，因为这个 UIImageView 已经显示了正确的图片。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// 只在 DefaultRunLoopMode 模式中加载
func aw_downloadImageURL_delay(url:NSURL,
                               showloading:Bool,
                               completionBlock : AWImageLoaderCallback) {
    /// 要一开始就重置状态，因为后面的方法被延时提交，而在返回的时候可能已经又其他图片从快速缓存中获取了
    self.aw_image_set = false
    /// 如果已经有存在的图片，就不要在 DefaultRunLoopMode 中加载
    let loader = AWImageLoader()
    if let cached_image = loader.imageFromFastCache(url) {
        self.aw_hideLoading()
        self.aw_setImage(cached_image)
        self.aw_image_url = url
        completionBlock(cached_image, url)
        return
    }
    /// 开始延时获取图片内容
    let par = _AWImageLoaderPar(url: url, showLoading: showloading, completionBlock: completionBlock)
    self.performSelector(#selector(UIImageView.aw_downloadImageURL_p(_:)), withObject: par, afterDelay: 0.0, inModes: [NSDefaultRunLoopMode,])
}
/// 延时提交的方法，由于这个方法延时提交，所以可能 cell 在下一次的 reuse 中已经获得了 image， 而此时又开始执行这个方法时就第二次获得了内容，他又会替换第一次的内容，因此在开始前先判断一下是否有图片被设置了；
&amp;#64;objc private func aw_downloadImageURL_p(par:_AWImageLoaderPar) {
    if self.aw_image_set {
        NSLog("image existed")
        return
    }
    self.aw_downloadImageURL(par.url, showLoading: par.showLoading, completionBlock: par.completionBlock)
}
&amp;#64;objc
private func aw_setImage(image:UIImage){
    self.image = image
    self.aw_image_set = true /// 设置图片后更新 aw_image_set,防止后面的任务会替换现在的图片
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;完整的 AWebImage 以及 Demo App 代码&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/adow/AWebImage" title=""&gt;https://github.com/adow/AWebImage&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;由于 500px.com在墙外，这里例子中的图片有时会下载不成功，这时在 UIImageView 中显示的都是空白的图片，并且在下一次滚动后界面更新时会重新尝试下载。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    <link href="http://codingnext.com/you-forget-nsurlcache.html" rel="alternate"/>
    <published>2016-06-13T00:00:00+08:00</published>
  </entry>
  <entry>
    <id>nsurlcache.html</id>
    <title>说说 NSURLCache 中的那些坑</title>
    <updated>2017-11-16T02:29:15.668115+00:00</updated>
    <author>
      <name>adow</name>
      <email>reynoldqin@gmail.com</email>
    </author>
    <content type="html">&lt;p&gt;我估计有很多人都会跟我一样在 iOS App 中自己去实现一个缓存 (Cache), 最常见的地方是一些图片下载和在线的配置参数。即使去看看现在主流的图片下载工具，比如 SDWebImage, 或者 Kingfisher, 他们也都自己建了一套缓存。&lt;/p&gt;

&lt;p&gt;为什么我们去建一套自己的缓存而不是使用系统内置的呢？&lt;/p&gt;

&lt;p&gt;我估计很多人都跟我想的一样，因为觉得实现缓存是一种非常简单的事情，如果要重新造一个轮子的话，这是一个非常易于上手的项目，然后我们就开始实现各种 XXXCache 了。&lt;/p&gt;

&lt;p&gt;对我而言，虽然我很早就开始写 iOS App，但是却一直不知道有 NSURLCache/NSCache 这样的存在，然后又因为觉得这个非常简单啊，所以在我的很多 App 中，都有不同方式实现的 Cache。直到前两年我看到了这篇文章，&lt;a href="http://nshipster.cn/nsurlcache/" title=""&gt;NSURLCache&lt;/a&gt;，我才焕然大悟，原来我白折腾了这么多年。&lt;/p&gt;

&lt;p&gt;事实上，只要两行代码就可以配置完 App 中所有请求的缓存，剩下的只要依靠 &lt;code&gt;http&lt;/code&gt; 响应头中 &lt;code&gt;Cache-Control&lt;/code&gt; 的设置就可以完成自动的缓存和管理了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)application:(UIApplication *)application
didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  NSURLCache *URLCache = [[NSURLCache alloc] initWithMemoryCapacity:4 * 1024 * 1024
                                                       diskCapacity:20 * 1024 * 1024
                                                           diskPath:nil];
  [NSURLCache setSharedURLCache:URLCache];
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于, NSURLCache 可以同时缓存在内存和磁盘上，而且他还会根据 &lt;code&gt;Cache-Control&lt;/code&gt; 以及系统资源的压力而自动管理，我现在将本地所有的缓存都替换了。&lt;/p&gt;

&lt;p&gt;但是在使用的过程中，我却发现了几个坑要注意:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果一个请求的响应内容的大小超过了 NSURLCache 中对应磁盘大小的 5%, 他就不会被缓存；我之前一直没有找到这条规则，但是我有一个图片的请求永远都没法缓存下来（我设置的 NSURLCache 中磁盘大小是 10MB, 但是这个图片有 3.8 MB）, 直到我在 &lt;code&gt;optional func URLSession(_ session: NSURLSession, dataTask dataTask: NSURLSessionDataTask, willCacheResponse proposedResponse: NSCachedURLResponse, completionHandler completionHandler: (NSCachedURLResponse?) -&gt; Void)&lt;/code&gt; 中看到了说明&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The response size is small enough to reasonably fit within the cache. (For example, if you provide a disk cache, the response must be no larger than about 5% of the disk cache size.)&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果这个请求的响应头中有 &lt;code&gt;Transfer-Encoding: Chunked&lt;/code&gt;, 那他也不会缓存；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;事实上，在&lt;code&gt;optional func URLSession(_ session: NSURLSession, dataTask dataTask: NSURLSessionDataTask, willCacheResponse proposedResponse: NSCachedURLResponse, completionHandler completionHandler: (NSCachedURLResponse?) -&gt; Void)&lt;/code&gt; 中对于缓存的条件还有一些限制，比如 &lt;code&gt;NSURLSessionConfiguration&lt;/code&gt; 中没有禁止缓存，&lt;code&gt;NSMutableURLRequest&lt;/code&gt; 中没有禁止缓存等。这个方法属于 &lt;code&gt;NSURLSessionDataDelegate&lt;/code&gt;, 但是有时你会发现 &lt;code&gt;NSURLSession&lt;/code&gt; 中设置的 &lt;code&gt;delegate&lt;/code&gt;后，一个回调函数都没有被调用&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当你使用类似 &lt;code&gt;func dataTaskWithURL(_ url: NSURL, completionHandler completionHandler: (NSData?, NSURLResponse?, NSError?) -&gt; Void) -&gt; NSURLSessionDataTask&lt;/code&gt; 这些带有 &lt;code&gt;completionHandler&lt;/code&gt; 的方法时，delegate 将不会被调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这一点确实很奇怪，因为这个原因，当我使用带有 &lt;code&gt;completionHandler&lt;/code&gt; 时，我甚至都不能通过 &lt;code&gt;willCacheResponse&lt;/code&gt; 来强制缓存了。&lt;/p&gt;

&lt;p&gt;除此之外，我还发现了 NSULRRequest 中对请求超时时间的设置几乎是没用的，当你设置 &lt;code&gt;timeoutInterval&lt;/code&gt; 为很小的值，比如 &lt;code&gt;10s&lt;/code&gt; 的时候，他不会起任何作用。Google 了一圈，有人说貌似这时 Apple 故意这么设计的，你不能指定小余 &lt;code&gt;240s&lt;/code&gt; 的数字, 但是有人说这个已经改过了，也有人说这个限制只针对 POST 请求，可以参考这几个链接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/11718256/nsurlrequest-timeout-ios" title=""&gt;NSURLRequest Timeout IOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/1466389/nsmutableurlrequest-timeout-interval-not-taken-into-consideration-for-post-reque" title=""&gt;NSMutableURLRequest timeout interval not taken into consideration for POST requests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/10408185/timeout-for-nsmutableurlrequest-not-working" title=""&gt;Timeout for NSMutableURLRequest not working&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是我发现我设置的超时时间都没有起过作用, 现在唯一的解决办法就是去设置一个 &lt;code&gt;NSTimer&lt;/code&gt; 然后手动取消请求了。&lt;/p&gt;
</content>
    <link href="http://codingnext.com/nsurlcache.html" rel="alternate"/>
    <published>2016-05-15T00:00:00+08:00</published>
  </entry>
  <entry>
    <id>awpromise.html</id>
    <title>探究 Promise 对象</title>
    <updated>2017-11-16T02:29:15.669005+00:00</updated>
    <author>
      <name>adow</name>
      <email>reynoldqin@gmail.com</email>
    </author>
    <content type="html">&lt;p&gt;Promise 对象的出现归根到底是为了拯救陷落在无数闭包大括号中的我们。虽然这个笑话经常出现在吐槽 Javascript 的段子中，但是在现在 Objective-C 和 Swift 充斥着无数滥用闭包/Block 的 iOS 中，难道不是一样的么。&lt;/p&gt;

&lt;p&gt;为了避免在异步嵌套代码中出现一层又一层的大括号，天才的程序员们发明了 Promise 对象，用一种面向对象的方式来解决多层闭包嵌套的问题。以下是从 &lt;code&gt;PromiseKit.org&lt;/code&gt; 中抄袭来的一段代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;login()
.then {

    // our login method wrapped an async task in a promise
    return API.fetchKittens()

}.then { fetchedKittens in

    // our API class wraps our API and returns promises
    // fetchKittens returned a promise that resolves with an array of kittens
    self.kittens = fetchedKittens
    self.tableView.reloadData()

}.error { error in

    // any errors in any of the above promises land here
    UIAlertView(…).show()

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;login()&lt;/code&gt; 作为一个封装了异步调用的函数，他返回了一个 &lt;code&gt;Promise&lt;/code&gt; 对象，而这个 Promise 对象有一个 &lt;code&gt;then&lt;/code&gt; 方法，他传入一个闭包并返回一个新的 &lt;code&gt;Promise&lt;/code&gt; 对象，而这个 &lt;code&gt;Promise&lt;/code&gt; 对象又可以调用他的 &lt;code&gt;then&lt;/code&gt; 方法...， 这样通过很多 &lt;code&gt;then&lt;/code&gt; 方法来实现多层的联级调用。&lt;/p&gt;

&lt;p&gt;这段文字看上去比代码更加绕口，其实就是 一个 Promise 对象通过 &lt;code&gt;then&lt;/code&gt; 方法传入一个闭包，他其实是告诉这个 Promise 对象，完成当前的操作后，后面将干什么。&lt;/p&gt;
&lt;h2&gt;构造 Promise 对象&lt;/h2&gt;
&lt;p&gt;Promise 对象在构造时会传入一个闭包，一般他应该是一段异步操作代码，当这段操作完成时，要么调用 &lt;code&gt;resolve&lt;/code&gt; 方法用来告诉 Promise 对象我正确操作完成了，要么调用 &lt;code&gt;reject&lt;/code&gt; 告诉 Promise 对象有地方出错了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AWPromise&amp;lt;NSData&amp;gt;(block: { (resolve, reject) in
            print("start")
            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), {
                print("wait")
                NSThread.sleepForTimeInterval(3.0)
                dispatch_sync(dispatch_get_main_queue(), {
                    print("wait complete")
                    resolve(NSData())
                })

            })
        })&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Promise 构造函数内部，&lt;code&gt;resolve&lt;/code&gt; 调用的时候，会保存运行的结果，并修改状态为 &lt;code&gt;FullFilled&lt;/code&gt;；&lt;code&gt;reject&lt;/code&gt; 调用的时候，会保存出错信息，并修改状态为 &lt;code&gt;Rejected&lt;/code&gt;。 以下是 Promise 对象的构造函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias ResolveFunc = (T) -&amp;gt; ()
typealias RejectFunc = (NSError) -&amp;gt; ()
typealias PromiseBlock = (resolve:ResolveFunc,reject:RejectFunc) -&amp;gt; ()
/// 用来保存后续操作
var f_then : ResolveFunc? = nil
/// 用来保存错误处理
var f_error : RejectFunc? = nil
/// 状态
var state:AWPromiseState = .Panding
/// 运行的结果
var result : AWResult&amp;lt;T&amp;gt;? = nil
init(&amp;#64;noescape block:PromiseBlock){
    block(resolve: { (t) in
        self.complete(t)
    }) { (error) in
        self.fail(error)
    }
}
func complete(t:T) -&amp;gt; () {
    self.result = AWResult.Success(t)
    state = .FullFilled
    f_then?(t) /// 如果 promise 内是同步函数， f_then 是还未被赋值时就被 complete 调用的
}
func fail(error:NSError) -&amp;gt; () {
    self.result = AWResult.Error(error)
    state = .Rejected
    f_error?(error)
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Promise 对象的状态&lt;/h2&gt;
&lt;p&gt;Promise 对象会有三种状态:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Panding: 刚开始构造函数，其中的闭包还没完成的时候&lt;/li&gt;
&lt;li&gt;FullFilled: 操作完成了；&lt;/li&gt;
&lt;li&gt;Rejected: 操作完成但是出错了；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;为什么可以实现联级调用&lt;/h2&gt;
&lt;p&gt;每个 &lt;code&gt;then&lt;/code&gt; 返回一个新的 Promise 对象，你又可以调用这个 Promise 对象的 &lt;code&gt;then&lt;/code&gt; 方法，从而实现联级调用。&lt;/p&gt;

&lt;p&gt;当调用 &lt;code&gt;then&lt;/code&gt; 的时候，传入的闭包参数将会被 &lt;code&gt;Promise&lt;/code&gt; 对象保存下来，并在当前这个 Promise 完成自己的操作后，执行后续操作时被调用。&lt;/p&gt;

&lt;p&gt;所以，在每个 &lt;code&gt;Promise&lt;/code&gt; 对象中含有一个非常重要的属性 &lt;code&gt;f_then&lt;/code&gt;, 他将在自己的任务完成后被调用，由于他实际上包含了 &lt;code&gt;then&lt;/code&gt; 方法中传递进来的操作代码块，所以实际上，&lt;code&gt;f_then&lt;/code&gt; 的调用就是执行了之前 &lt;code&gt;then&lt;/code&gt; 传递来的代码块。&lt;/p&gt;

&lt;p&gt;所以正确的流程是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;构造 Promise 对象时传入异步代码块;&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;then&lt;/code&gt; 方法为当前的 &lt;code&gt;Promise&lt;/code&gt; 对象保存下一步需要操作的代码块，同时他返回一个新的 &lt;code&gt;Promise&lt;/code&gt; 对象，并重复这一过程；&lt;/li&gt;
&lt;li&gt;每个 Promise 对象的代码块执行完成的时候，他会调用 &lt;code&gt;f_then&lt;/code&gt; 操作后面的过程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于每个 Promise 对象构造方法中传入的都是异步代码块，所以当进行 Promise &lt;strong&gt;对象完成构造&lt;/strong&gt; 时，其中的代码应该还没有被执行完成，所以肯定是后续的 &lt;code&gt;then&lt;/code&gt; 方法会比构造方法中的异步代码块先执行（未验证这种说法，但是这并不会成为问题，因为我们下面会处理构造方法闭包参数中使用同步代码的情况）。当构造参数闭包中的异步代码终于完成时，我们的 Promise 对象已经持有了下一步继续操作所需的代码块 &lt;code&gt;f_then&lt;/code&gt;，所以通过对他的调用就完成了后续代码的调用。&lt;/p&gt;
&lt;h3&gt;then 中嵌套另一个异步过程的情况&lt;/h3&gt;
&lt;p&gt;如果要在 &lt;code&gt;then&lt;/code&gt; 中使用另一个异步代码时，我们必须构造另一个 &lt;code&gt;Promise&lt;/code&gt; 对象，并在其中完成异步代码，就和创建第一个 &lt;code&gt;Promise&lt;/code&gt; 对象的方法一样。&lt;/p&gt;

&lt;p&gt;这样，&lt;code&gt;then&lt;/code&gt; 方法将有另一种形式的参数，也就是他的闭包参数类型中应该返回一个 &lt;code&gt;Promise&lt;/code&gt; 类型。&lt;/p&gt;

&lt;p&gt;所以，他其实有两种形式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func then&amp;lt;U&amp;gt;(f: (T throws -&amp;gt; U)) -&amp;gt; AWPromise&amp;lt;U&amp;gt;
func then&amp;lt;U&amp;gt;(f : (T throws -&amp;gt; AWPromise&amp;lt;U&amp;gt;)) -&amp;gt; AWPromise&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恰好对应了 &lt;code&gt;flat/flatMap&lt;/code&gt; 的写法。&lt;/p&gt;
&lt;h2&gt;then 内包含非异步代码怎么办&lt;/h2&gt;
&lt;p&gt;前面我们的假设都是建立在一个前提下的：&lt;/p&gt;

&lt;p&gt;当我们调用 Promise 对象的 &lt;code&gt;then&lt;/code&gt; 方法用来注册下一步操作的代码块时，Promise 构造方法中传入的异步代码还未完成调用。所以当异步操作完成时， &lt;code&gt;f_error&lt;/code&gt; 已经知道该在下一步做什么了。&lt;/p&gt;

&lt;p&gt;但是有没有一种可能是，异步操作比 &lt;code&gt;then&lt;/code&gt; 调用先完成呢。我觉得应该是有可能的，如果后续的 &lt;code&gt;then&lt;/code&gt; 方法调用中有一处阻塞了主线程呢，那异步操作可能会先完成。&lt;/p&gt;

&lt;p&gt;还有一种更直接的做法是，构造 Promise 对象的闭包中，只有同步的代码，那他可以肯定会在 &lt;code&gt;then&lt;/code&gt; 前完成（在 Promise 对象构造中就完成了）。&lt;/p&gt;

&lt;p&gt;这种时候我们就没法正确的调用 &lt;code&gt;f_then&lt;/code&gt;,因为他还没有被赋值。&lt;/p&gt;

&lt;p&gt;为了解决这种情况，就需要对 &lt;code&gt;then&lt;/code&gt; 调用做些处理，当&lt;code&gt;then&lt;/code&gt; 调用时，如果 &lt;code&gt;Promise&lt;/code&gt; 操作还没完成，他就需要通过 &lt;code&gt;f_then&lt;/code&gt; 来保存下一步操作代码块。如果 Promise 已经完成了自己的工作了，我们就直接调用 &lt;code&gt;then&lt;/code&gt; 传递来的代码块，将结果传递出去。&lt;/p&gt;

&lt;p&gt;当然我们不得不说，在 Promise 构造函数中的闭包中传递同步代码是一种很蛋疼的行为，因为你完全没必要这么做，把他们放在 &lt;code&gt;promise/then&lt;/code&gt; 的外部执行不是更加清楚么。&lt;/p&gt;
&lt;h2&gt;错误处理&lt;/h2&gt;
&lt;p&gt;在 Promise 对象中有一个 &lt;code&gt;error&lt;/code&gt; 方法，传递一个闭包参数，用来处理发送异常时的情况。 &lt;code&gt;error&lt;/code&gt; 不会返回新的 &lt;code&gt;Promise&lt;/code&gt;, 所以不能被联级调用，他应该在整个调用链的最后被调用，只要操作链中有一处抛出错误，就会调用 &lt;code&gt;error&lt;/code&gt; 传递来的代码块（他被保存在 &lt;code&gt;f_error&lt;/code&gt; 中）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.error { (error) in
            print("\(error.domain)")
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在构造 Promise 的闭包中，我们通过 &lt;code&gt;reject&lt;/code&gt; 函数调用来抛出一个错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AWPromise&amp;lt;NSData&amp;gt;(block: { (resolve, reject) in
            print("start")
            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), {
                print("wait")
                NSThread.sleepForTimeInterval(3.0)
                dispatch_sync(dispatch_get_main_queue(), {
                    print("wait complete")
                    let error = NSError(domain: "test error", code: 1, userInfo: nil)
                    reject(error)
                })

            })
        })&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;then&lt;/code&gt; 代码中，我们没法调用 &lt;code&gt;reject&lt;/code&gt; 方法，最简单的 &lt;code&gt;throw&lt;/code&gt; 一个异常。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.then { (data) -&amp;gt; [String:String] in
      throw AWPromiseError.PromiseError("1 error")
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是我们每个 &lt;code&gt;then&lt;/code&gt; 产生的都是一个全新的 &lt;code&gt;Promise&lt;/code&gt; 对象，而且我们要求 &lt;code&gt;error&lt;/code&gt; 必须在调用链的最后被调用，所以错误代码其实只在最后一个 &lt;code&gt;Promise&lt;/code&gt; 对象上面保存着。&lt;/p&gt;

&lt;p&gt;为了能顺着调用链执行错误处理，我们必须在每个 &lt;code&gt;Promise&lt;/code&gt; 对象中都持有下一个 &lt;code&gt;Promise&lt;/code&gt; 对象的错误处理方法，这样当调用链中发生异常时，每个 Promise 对象会调用错误处理方法, 直到最后一个 Promise 中正在开始真正的处理这个错误（因为只有他持有 f_error 操作块）。&lt;/p&gt;

&lt;p&gt;所以在 &lt;code&gt;then&lt;/code&gt; 中和处理 &lt;code&gt;f_then&lt;/code&gt; 一样，将新的 Promise 对象的 &lt;code&gt;reject&lt;/code&gt; 操作赋值给 &lt;strong&gt;当前对象&lt;/strong&gt; 的 &lt;code&gt;f_error&lt;/code&gt;。 在 &lt;code&gt;then&lt;/code&gt; 中类似这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func then&amp;lt;U&amp;gt;(f: (T throws -&amp;gt; U)) -&amp;gt; AWPromise&amp;lt;U&amp;gt; {
        return AWPromise&amp;lt;U&amp;gt;(block: { (resolve, reject) in
            self.f_error = reject /// 错误处理
            self.f_then = { (t:T) -&amp;gt; () in /// 下一步操作
                let u = f(t)
                resolve(u)
            }
        })
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;完整使用 Promise 对象进行网络请求的例子&lt;/h2&gt;
&lt;p&gt;下面的例子将依次发起两次网络请求，第一次访问 &lt;code&gt;https://www.zhihu.com&lt;/code&gt;, 在获取到内容后，再发起第二次网络请求 &lt;code&gt;http://www.apple.com&lt;/code&gt;。两次请求都会输出获取到的内容，并在两次都完成后输出 &lt;code&gt;All Completed&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func test_http_promise() {
    /// NSURLSession 的一些配置
    let queue = NSOperationQueue()
    let sessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration()
    sessionConfiguration.timeoutIntervalForRequest = 3.0

    /// 1. 构造第一个请求
    AWPromise&amp;lt;NSData&amp;gt; (block:{ (resolve, reject) in
        let session = NSURLSession(configuration: sessionConfiguration, delegate: nil, delegateQueue: queue)
        let task = session.dataTaskWithURL(NSURL(string:"https://www.zhihu.com")!, completionHandler: { (data, response, error) in
            dispatch_sync(dispatch_get_main_queue(), { 
                if let error = error {
                    reject(error)
                }
                else if let data = data {
                    resolve(data)
                }    
            })
        })
        task.resume()
    })
    /// 2. 第一个请求返回结果
    .then { (data) -&amp;gt; () in
        print("First Request")
        let str = String(data: data, encoding: NSUTF8StringEncoding)
        print(str)
    }
    /// 3. 构造第二个请求
    .then { () -&amp;gt; AWPromise&amp;lt;NSData&amp;gt; in
        return AWPromise&amp;lt;NSData&amp;gt;(block: { (resolve, reject) in
            let session = NSURLSession(configuration: sessionConfiguration, delegate: nil, delegateQueue: queue)
            let task = session.dataTaskWithURL(NSURL(string:"https://www.apple.com")!, completionHandler: { (data, response, error) in
                dispatch_sync(dispatch_get_main_queue(), { 
                    if let error = error {
                        reject(error)
                    }
                    else if let data = data {
                        resolve(data)
                    }    
                })
            })
            task.resume()
        })
    }
    /// 4. 第二个请求返回结果，这里先转换到 String
    .then { (data) -&amp;gt; String in
        let str = String(data: data, encoding: NSUTF8StringEncoding)!
        return str
    }
    /// 5. 得到第二个请求的结果的字符串
    .then { (str) -&amp;gt; () in
        print("Second Request")
        print(str)
        print("All Completed")
    }
    /// 6. 用来处理错误
    .error { (error) in
        debugPrint(error)
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;当第一个请求构造的时候，位于 &lt;code&gt;1&lt;/code&gt; 的位置，我们创建一个 Promise 对象，并传入一个闭包，这个闭包是一个异步网络请求;&lt;/li&gt;
&lt;li&gt;当这个异步请求完成的时候，调用这个 Promise 对象的 &lt;code&gt;then&lt;/code&gt; 方法，这时位于 &lt;code&gt;2&lt;/code&gt;, 他会得到一个 &lt;code&gt;NSData&lt;/code&gt; 内容，是(dataTaskWithRequest)回调时的 &lt;code&gt;NSData&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;我们还想要做后续操作，所以可以继续使用 &lt;code&gt;then&lt;/code&gt;, 由于下面一步并不需要来自前面的结果，所以 &lt;code&gt;then&lt;/code&gt; 中的闭包并没有传递来参数，这时在 &lt;code&gt;3&lt;/code&gt; 的位置，我们要构建第二个异步网络请求，访问 &lt;code&gt;https://www.apple.com&lt;/code&gt;， 因为他又是一个异步请求，所以我们又要构造一个 Promise 对象用来封装这个过程。&lt;/li&gt;
&lt;li&gt;第二个请求返回的时候来到 &lt;code&gt;4&lt;/code&gt;, 得到了 &lt;code&gt;NSData&lt;/code&gt; 数据，为了让代码看上去更清晰一点，我们在这里没有做更多的处理，只将他转换到 &lt;code&gt;String&lt;/code&gt; ，然后将这后面工作划分到下面一步完成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;5&lt;/code&gt; 的时候得到了前面传递来的 &lt;code&gt;String&lt;/code&gt;, 输出来，这样我们完成了全部流程了；&lt;/li&gt;
&lt;li&gt;如果将第二个请求的地址改为 &lt;code&gt;https://www.google.com&lt;/code&gt;, 由于一些奇怪的因素，第二个请求会发生错误， 这时会到 &lt;code&gt;6&lt;/code&gt;，输出错误信息了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其实我们可以发现，其中很多步是可以合并的，比如 &lt;code&gt;2&lt;/code&gt; 和 &lt;code&gt;3&lt;/code&gt; 可以合并，直接在 &lt;code&gt;2&lt;/code&gt; 中构造下一步的 Promise 对象， &lt;code&gt;4&lt;/code&gt; 和 &lt;code&gt;5&lt;/code&gt; 可以合并，之所以将他们分开，是为了让每个步骤的代码块更加清晰，事实上使用多少层 &lt;code&gt;then&lt;/code&gt; 的链式调用完全取决于你想以多大的规模来区分每一步。&lt;/p&gt;
&lt;h2&gt;这里实现的 Promise 对象全部代码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/adow/8e638a907ecb1a476f783663cb76b5db" title=""&gt;AWPromise.swift&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;何去何从&lt;/h2&gt;
&lt;p&gt;我们在这里构造了一个 &lt;code&gt;Promise&lt;/code&gt; 对象，用来将多层的异步代码嵌套以更直观的方法写出来。他可以实现:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;封装异步/同步代码;&lt;/li&gt;
&lt;li&gt;错误处理;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然实现了这些功能，代码看看整个 &lt;code&gt;AWPromise.swift&lt;/code&gt; 的代码实现却一点也不谈不上简洁 （虽然只有 200 行不到的代码）,隐约中还感到某些地方有哪些问题却还发现不了。这个 Promise 远远达不到 &lt;a href="http://promisekit.org/" title=""&gt;PromiseKit&lt;/a&gt; 的强大和优雅，所以我写下本文的目的在于探究 Promise 对象的实现过程。如果真的要在项目中使用 Promise 的话，强烈推荐使用 &lt;code&gt;PromiseKit&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们用 Promise 对象来转换异步代码的写法，说白了是为了让异步代码看上去更加的直白而已（或者叫异步代码扁平化处理），其实使用 Promise 对象所带来的直观感受远远不如另外两项技术带来的更加直观。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;Python&lt;/code&gt; 和 &lt;code&gt;ECMAScript 6&lt;/code&gt; 中，由于有 &lt;code&gt;Generator&lt;/code&gt;, &lt;code&gt;Yield&lt;/code&gt; 的存在，最好配合函数的属性标签, 可以将异步代码写成完全的扁平化。&lt;/p&gt;

&lt;p&gt;比如，使用 &lt;code&gt;Python&lt;/code&gt; 中著名的 &lt;code&gt;Tornado&lt;/code&gt; 框架的话，可以将一个异步函数改为下面这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;#64;gen.coroutine
def get(self):
    http_client = AsyncHTTPClient()
    response = yield http_client.fetch("http://example.com")
    self.write(response)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;yiled&lt;/code&gt; 关键字将当前函数转换为 &lt;code&gt;Generator&lt;/code&gt;，只有当 &lt;code&gt;http_client&lt;/code&gt; 获取到内容并赋值给 &lt;code&gt;response&lt;/code&gt; 之后，后续的代码才会继续执行。&lt;/p&gt;

&lt;p&gt;甚至到了 &lt;code&gt;Python3&lt;/code&gt; 和 &lt;code&gt;ECMAScript 7&lt;/code&gt; 中， 都有 &lt;code&gt;async/await&lt;/code&gt; 关键字，专门用来实现异步代码的扁平化处理（其实就是 Generator 和 Yield 的语法糖）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var asyncReadFile = async function (){
  var f1 = await readFile('/etc/fstab');
  var f2 = await readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift 中什么时候才能引入这样的特性呢？&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://zhuanlan.zhihu.com/prattle/20209175" title=""&gt;Promise: 给我一个承诺，我还你一个承诺&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/&lt;a href="/people/robringham/" class="user-mention"&gt;@robringham&lt;/a&gt;/promises-in-swift-66f377c3e403#.4wtrrnmmr" title=""&gt;Promises in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/lvdabao/p/es6-promise-1.html" title=""&gt;大白话讲解Promise（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://gold.xitu.io/entry/56c52be6d342d30053c8a254" title=""&gt;如何处理 Swift 中的异步错误&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.infoq.com/cn/articles/swift-brain-gym-monad?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global" title=""&gt;Swift 烧脑体操（五）- Monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://swiftggteam.github.io/2015/10/30/lets-talk-about-monads/" title=""&gt;聊一聊单子（Monad）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/#jtss-tsina" title=""&gt;Functor、Applicative 和 Monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cocoachina.com/swift/20160210/15068.html" title=""&gt;Swift 数组中 Map,FlatMap,Filter,Reduce的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zyden.vicp.cc/map-those-arrays/?" title=""&gt;为Swift编码引入map()和flatMap(), map those arrays&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    <link href="http://codingnext.com/awpromise.html" rel="alternate"/>
    <published>2016-05-09T00:00:00+08:00</published>
  </entry>
  <entry>
    <id>hard-mode.html</id>
    <title>习惯性 Hard 模式</title>
    <updated>2017-11-16T02:29:15.671728+00:00</updated>
    <author>
      <name>adow</name>
      <email>reynoldqin@gmail.com</email>
    </author>
    <content type="html">&lt;p&gt;不知道从什么时候开始，做什么事情我都习惯性的开启 Hard 模式，但事实上，我是一个级怕麻烦的人啊。&lt;/p&gt;

&lt;p&gt;玩实况足球 (PES 2016) 的时候，虽然我已经有5年没有玩这个游戏了，打开游戏的第一件事就是到设置里面去将难度调到最高（顶级球星），我只使用每年都只能获得联赛第四，欧冠16强出局的那个队。在和电脑对战中，我只要将阵型保持紧凑，不要无谓的失误，即使在刚开始玩的时候，也不大会输球。然而，我却喜欢胡乱的高位逼抢，即使对方已经将球传到中圈时也仍然让所有的人压迫防守。聪明的球队经常用简单的直传打穿我的中场线。而且即使开局连丢几球，我也仍然疯狂的高压式的防守，因为头脑中的 Hard 模式已经开启，完成一场逆转更让我兴奋，最后的结果是两队变成了一种完全开放式的进攻，节奏异常快，运气好时，我可以完成逆转，但是大多数时候在这样的比赛中我都不会赢。&lt;/p&gt;

&lt;p&gt;明明有一条更简单轻松的路放在你的面前，而你却选择另一条充满风险的小路，这就是 Hard 模式，在很多时候，这已经成为一种习惯了。&lt;/p&gt;

&lt;p&gt;而且写程序的时候几乎是全程 Hard 模式。 &lt;/p&gt;

&lt;p&gt;我每次开启一个新的项目都会格外的兴奋，因为每个新的项目我都会去挑战新的难度。如果让我去复制一个已经做过的项目，我会毫无热情，以前的代码连看一眼的兴趣都没有。我们都知道，代码是可以重复使用的，这是因为代码都是抽象的，而抽象的东西都具有普遍性。一个经验丰富的程序员写了很多代码，犯过很多错误，这些都是宝贵的财富。在我每个新的项目中，我都避免去使用自己在前面的项目中已经熟练使用的技术，刻意的去使用并没有太多经验的技术。比如刚开始的项目中我会尝试所有的界面中必须用 Storyboard 来设计；后面一个项目中，我强迫自己只能使用系统框架中自带的两个丑陋的 Autolayout 布局 Api；到第三个项目中我会使用 Cartography 来实现所有界面布局代码；到了最近的项目我又将他们改成全部用 SnapKit。其实他们都是完成同样的工作。不管使用哪种技术来写页面，在实践过程中都充满了各种坑要踩，而我却莫名的开启了 Hard 模式，乐此不疲，一定要走一条和之前完全不同的路。&lt;/p&gt;

&lt;p&gt;Hard 模式的偏爱让我在完成每个项目中都遇到了不小的挑战，每次都从头开始，每次都掉入新的坑里，每次都花费比预想更多的时间。就如开头所说的，我其实是一个级怕麻烦的人，但是在编码的过程中却一次又一次的给自己找麻烦。要说原因的话，也许是因为我还喜欢写代码。因为热情还在，我依旧会去尝试使用新的技术，我依旧还会去看各种书，或者把他们看很多遍，因为热情还在，我明明能够去 github 上找一堆现成的代码，但是还是要多花几个小时去写自己的轮子。&lt;/p&gt;

&lt;p&gt;作为这样的程序员理所当然的会很累，因为干的活比预想的多的多，但是这不是我开始反思自己进入 Hard 模式怪圈的主要原因。每当一个项目结束，我都是精疲力尽，再也提不起兴趣去总结这个项目中所得到的经验了。更不用说，其实在每一个项目中，都有因为时间无法满足而留下的丑陋的代码，他们原本应该被更好的设计。虽然我在每个项目中都将某一个技术钻研的很透彻，毕竟当你在一个完整的项目中使用一项技术时，遇到的困难永远都是比单单在网上看看别人写的教程多的多的。总感觉还差那么一点，明明原来我可以做的比现在更好的，因为有遗憾，所以更不想去看那些不够好的代码。&lt;/p&gt;

&lt;p&gt;回头再看看自己写代码的十几年，我应该已经学习了足够多的技术，既然选择用 Hard 模式的方式干活，我想是时候开始另一种策略了。不再追求更新的技术，而是尝试更加深入的研究已经学会的东西，强迫自己更加精益的设计结构，多写点让自己看的顺眼的代码吧。&lt;/p&gt;

&lt;p&gt;等等，这是不是更加 Hard 了？&lt;/p&gt;
</content>
    <link href="http://codingnext.com/hard-mode.html" rel="alternate"/>
    <published>2016-04-19T00:00:00+08:00</published>
  </entry>
  <entry>
    <id>tools-2016.html</id>
    <title>2016 我的工具箱</title>
    <updated>2017-11-16T02:29:15.672118+00:00</updated>
    <author>
      <name>adow</name>
      <email>reynoldqin@gmail.com</email>
    </author>
    <content type="html">&lt;h2&gt;开发工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.apple.com/cn/xcode/downloads/" title=""&gt;Xcode&lt;/a&gt;：开发 iOS App 的唯一工具，虽然有一些其它的选择，但是从未尝试过。我使用 &lt;a href="https://github.com/ArtSabintsev/Solarized-Dark-for-Xcode" title=""&gt;Solarize Dark&lt;/a&gt; 的配色方案。2015 年开始已经不再用 Objective-C，写新的 App 全部使用 Swift。我只有一个 &lt;a href="https://github.com/XVimProject/XVim" title=""&gt;XVim&lt;/a&gt; 的插件，只为了使用 Vim 的键盘布局。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.vim.org/" title=""&gt;Vim&lt;/a&gt;/&lt;a href="https://github.com/b4winckler/macvim" title=""&gt;MacVim&lt;/a&gt;：出了 iOS App，其它都使用 MacVim，和 XCode 中使用一样的颜色主题 &lt;a href="https://github.com/altercation/vim-colors-solarized" title=""&gt;Solorize Dark&lt;/a&gt;。大部分用来写 Python，有时写 javascript 和 html，css。 我并没有使用太多的插件，最常用的是 &lt;a href="https://github.com/wincent/command-t" title=""&gt;Command-T&lt;/a&gt;，&lt;a href="https://github.com/Valloric/YouCompleteMe" title=""&gt;YouCompleteMe&lt;/a&gt;。我喜欢用 Vim，所以 Xcode 中也使用 XVim 插件，尽可能不让手离开键盘。当然最大的好处在于，我在服务器上可以自由的打开文件进行编辑，而不会不知所措。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.iterm2.com/" title=""&gt;iTerm2&lt;/a&gt;：代替了系统的 Terminal.app，我只用来做一些简单的服务器运维。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://kapeli.com/dash" title=""&gt;Dash&lt;/a&gt;：查 Api 文档全靠他了，用了 4 年，觉得是最值的 App 了。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://realmacsoftware.com/clear/" title=""&gt;Clear&lt;/a&gt;:  生活中的一些简单列表，比如购物列表，学习列表，Mac 和 iOS 可以同步实在是太方便了。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tower.im" title=""&gt;tower.im&lt;/a&gt;: 工作中的所有任务都通过 tower.im 来规划，实在搞不清这个团队（彩臣设计），已经很久没有大的更新了。其实很想尝试其他的服务，但是现在大家已经习惯在这里了。&lt;/li&gt;
&lt;li&gt;git: 我几乎不用 Gui 的 git 工具，平时都在 iTerm 中完成所有的操作。我还装了一个 &lt;a href="https://desktop.github.com/" title=""&gt;Github Desktop&lt;/a&gt;，很少打开，功能也非常简单。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com" title=""&gt;github.com&lt;/a&gt;/&lt;a href="https://coding.net" title=""&gt;coding.net&lt;/a&gt;:  从一开始，我就购买了 github.com 的个人版服务，只可惜他的私有仓库数实在太少。除了写了几个开源的项目之外，我用他来存放一些敏感度较高的代码和文档。由于私有仓库太少，我的大多数项目都存放在 coding.net。很多次，我考虑干脆不用 github.com 的个人版服务，而全部迁移到 coding.net，但是现在来看，还是有点不放心国内的服务商，很抱歉。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://reederapp.com/" title=""&gt;Reeder&lt;/a&gt;: 用来订阅新闻和技术博客，我以前每天要花好多时间看这些莫名其妙的文章，现在强制克制自己每天只刷两次，有用的文章存入 Pocket。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://getpocket.com/" title=""&gt;Pocket&lt;/a&gt;: 你懂的，Read it &lt;strong&gt;NEVER&lt;/strong&gt;，基本当个收藏夹用.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;写作和文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://itunes.apple.com/cn/app/mweb-lite-zhuan-ye-demarkdown/id979033429?mt=12" title=""&gt;MWeb Lite&lt;/a&gt;：写文档用，我曾经是 &lt;a href="http://25.io/mou/" title=""&gt;Mou.app&lt;/a&gt; 的死忠粉，从5年前刚开始用 Mac 时就开始用 Mou，还在众筹中支持了他们的新版本的开发。然后就如大家知道的那样，作者无耻的延期了不知道多少时间，已经放弃。后来用过 &lt;a href="https://programmerbird.com/letterspace/" title=""&gt;letterspace&lt;/a&gt;，最后还是改成用 MWeb Lite。最大的遗憾还是没有 iOS 版，有的话简直跟 &lt;a href="http://www.ulyssesapp.com/" title=""&gt;Ulysses&lt;/a&gt; 一样了。对了，我所有的文档都用 git 管理，并 push 到 github.com 的私有仓库中。&lt;/li&gt;
&lt;li&gt;Ming: 自己挖的坑，一个静态博客生成工具，现在还只是个丑陋的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;设计&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.sketchapp.com/" title=""&gt;Sketch&lt;/a&gt;：今年才开始学习用，感觉非常像 10几年前用过的 &lt;a href="https://zh.wikipedia.org/zh-cn/Adobe_Fireworks" title=""&gt;Fireworks&lt;/a&gt;。我用他设计了这个博客的主题，容易上手，使用非常方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;娱乐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.apple.com/cn/music/" title=""&gt;Apple Music&lt;/a&gt; 和 &lt;del&gt;网易云音乐&lt;/del&gt;: 现在已经逐步用 Apple Music 来听音乐了，这个理由也许很奇葩。我那辆车连上 iPhone 之后只可以播放 Apple Music （以前是 iPod.app ）的音乐，其他的 App 都播放不了声音，因为没有 Aux 接口。后来我想既然我都付了每个月10块钱了，干脆就多听听吧。当然国内的网络实在没法让你好好的使用，我只能把最近听的歌离线下来听听而已。&lt;/li&gt;
&lt;/ul&gt;
</content>
    <link href="http://codingnext.com/tools-2016.html" rel="alternate"/>
    <published>2016-03-16T00:00:00+08:00</published>
  </entry>
  <entry>
    <id>uitableview.html</id>
    <title>奇怪的 UITableView</title>
    <updated>2017-11-16T02:29:15.672860+00:00</updated>
    <author>
      <name>adow</name>
      <email>reynoldqin@gmail.com</email>
    </author>
    <content type="html">&lt;p&gt;从刚开始做 iOS 开发的时候开始，UITableView 就一直是被我用的做多的 UIKit 控件，这么多年过去了，有时还是会在使用 UITableView 的过程中遇到一些奇怪的问题。&lt;/p&gt;

&lt;p&gt;在大部分的开发过程中，每当遇到 UITableView 的奇怪的的现象，我总寄希望于自定义的 UITableViewCell, 也就是直接继承一个 UITableViewCell, 然后在上面添加自己的控件，这样的做法屡试不爽。但是过后，有时会在想，到底是什么原因会造成这样奇怪的问题呢？&lt;/p&gt;
&lt;h2&gt;Grouped UITableView 和 奇怪的 Section Header&lt;/h2&gt;
&lt;p&gt;当我们使用 UITableViewStyle.Grouped 的样式来创建一个 UITableView 的时候，而同时又去修改某个 Section 中的 header 高度时，就会出现很奇怪的现象:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在 UITableViewStyleGrouped 中，你不能直接把 heightForHeaderInSection 修改为一个很小的值 （小余 22.0）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;默认的情况下， heightForHeaderInSection 和 heightForFooterInSection 都是 &lt;code&gt;22.0&lt;/code&gt;，我们可以在 UITableViewDelegate 中来设置这两个值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func tableView(tableView: UITableView, heightForHeaderInSection section: Int) -&amp;gt; CGFloat {
    return 60.0
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的确起效果了，然而，当你指定的高度为 &lt;code&gt;10.0&lt;/code&gt; 时，显示的时候却仍然是 22.0 的高度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func tableView(tableView: UITableView, heightForHeaderInSection section: Int) -&amp;gt; CGFloat {
    return 10.0
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没错，就是怎么奇怪，当你设置小余 &lt;code&gt;22.0&lt;/code&gt; 的高度时候就是无效的。&lt;/p&gt;

&lt;p&gt;解决的办法也很奇葩， &lt;strong&gt;你必须同时指定一下 heightForFooterInSection, 比如指定一个非常小的值 (0.0001)&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func tableView(tableView: UITableView, heightForFooterInSection section: Int) -&amp;gt; CGFloat {
        return 0.0001
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的 Section Header 就显示正确了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个问题只有在使用 UITableViewStyle.Grouped 来创建 UITableView 的时候才会出现，而默认的样式中随意指定 Section Header 高度都是可以的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;设置 heightForFooterInSection 还顺带解决了另一个问题。有时我们会看到一个 UITableView 只有几行有内容（并没有撑满一屏）的时候，UITableView 会为剩余空白的地方仍然绘制分割线。而当你设置了 heightForFooterInSection 之后，他们就不会出现了，只会显示空的位置。&lt;/p&gt;
&lt;h2&gt;UITableViewCell 的分割线&lt;/h2&gt;
&lt;p&gt;为什么 UITableViewCell 的分割线不能从左边直接开始而非要留一些空呢？ 如果我们看看系统自带的 App, 他们中的分割线都是离左边有些距离的。似乎这就是现在 iOS 的设计风格。&lt;/p&gt;

&lt;p&gt;然而，我遇到的所有设计师都是会把这根线撑满整个 UITableViewCell 的宽度的。所以我做过的 App 中所有的 UITableViewCell 都需要改掉这跟线的位置。 在 &lt;code&gt;iOS7&lt;/code&gt; 中，只要直接修改 &lt;code&gt;UITableView.separatorInset&lt;/code&gt; 和 &lt;code&gt;UITableViewCell.separatorInset&lt;/code&gt; 就可以控制分割线的位置了。比如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tableView.separatorInset = UIEdgeInsetsZero
tableViewCell.speratorInset = UIEdgeInsetsZero&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是 iOS8/iOS9 这样却没用了, 因为从 iOS 8 开始，又有了一个 &lt;code&gt;layoutMargin&lt;/code&gt;，所以得改成:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.separatorInset = UIEdgeInsetsZero
    if #available(iOS 8.0, *) {
        self.layoutMargins = UIEdgeInsetsZero
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;UITableView/UITableViewCell&lt;/strong&gt; 中都得这样设置。而且奇怪的是， &lt;code&gt;iOS 8&lt;/code&gt; 中还得设置 &lt;code&gt;tableViewCell.preservesSuperviewLayoutMargins = false&lt;/code&gt; 才可以。而 &lt;code&gt;iOS 9&lt;/code&gt; 却不设置也可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension UITableViewCell {
/// 让分割线贴到左边
    func cx_fixSeperator() {
        self.separatorInset = UIEdgeInsetsZero
        if #available(iOS 8.0, *) {
            self.layoutMargins = UIEdgeInsetsZero
            self.preservesSuperviewLayoutMargins = false /// 只有 iOS8 需要这样
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用 UIAppearance&lt;/h3&gt;
&lt;p&gt;由于一般 App 中所有的 UITableView 风格都是统一的，我想应该直接可以通过 UIAppearance 来控制所有的分割线位置了吧，比如在 &lt;code&gt;func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool&lt;/code&gt; 中设置他：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UITableView.appearance().separatorInset = UIEdgeInsetsZero
    if #available(iOS 8.0, *) {
        UITableView.appearance().layoutMargins = UIEdgeInsetsZero
    }
    UITableViewCell.appearance().separatorInset = UIEdgeInsetsZero
    if #available(iOS 8.0, *) {
        UITableViewCell.appearance().layoutMargins = UIEdgeInsetsZero
    }
    if #available(iOS 8.0, *) {
        UITableViewCell.appearance().preservesSuperviewLayoutMargins = false
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;但是我又发现这样做没啥作用！？原因不明&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;去掉一个 UITableViewCell 的分割线的方法&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;UITableView.separatorStyle = UITableViewCellSeparatorStyle.None&lt;/code&gt;  可以去掉所有的分割线，那要是想去掉 &lt;strong&gt;其中一个&lt;/strong&gt; UITableViewCell 的分割线该怎么办呢? 其实也就是这时这个 Cell 的 &lt;code&gt;separatorInset/layoutMargins&lt;/code&gt;, 可以设置偏移到屏幕外面的距离去:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// 删除分割线
func cx_removeSeperator() {
    self.separatorInset = UIEdgeInsetsMake(0.0, 1000.0, 0.0, 0.0)
    if #available(iOS 8.0, *) {
        self.layoutMargins = UIEdgeInsetsMake(0.0, 1000.0, 0.0, 0.0)
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是你会发现有时这样做也是没用的，在 UITabelViewStyle.Grouped 的 UITableView 中，由于 UITableViewHeaderFooterView 上就会有一根分割线，所以以这样的方式来删除 section 中最后一个 cell 的分割线时，其实是没用的。&lt;/p&gt;

&lt;p&gt;同时，我发现用这种方法后会让 UITableView.textLabel 的内容偏移到后面去，所以这并不是一个好的方法。&lt;/p&gt;
&lt;h2&gt;被遮挡的子视图背景色&lt;/h2&gt;
&lt;p&gt;当 UITableViewCell 中增加一些子视图的时候，有时点击 Cell 的时候就会发现有些子视图的背景色不见了。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://7vihfk.com1.z0.glb.clouddn.com/Simulator%20Screen%20Shot%202016%E5%B9%B43%E6%9C%8830%E6%97%A5%20%E4%B8%8B%E5%8D%882.37.42.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;这是由于当点击 Cell 的时候，子元素会变成 Hightlighted 状态，而选中之后又会变成 Selected 状态，UITableViewCell 的状态会传递给子视图。有些 View (比如 UIButton, UILabel 等) 会根据状态呈现不同的样式的时候，他们就会在 UITableViewCell 被点击和选择的时候被呈现出不同的样子了。&lt;/p&gt;

&lt;p&gt;解决的办法是重写 UITableView 的 &lt;code&gt;- setSelected:animated:&lt;/code&gt; 和 &lt;code&gt;- setHighlighted:animated:&lt;/code&gt; 方法，并在这里设置子视图的样式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func setSelected(selected: Bool, 
    animated: Bool) {
    super.setSelected(selected, animated: animated)
    self.button.backgroundColor = UIColor.blackColor()

}
override func setHighlighted(highlighted: Bool, 
    animated: Bool) {
     super.setSelected(selected, animated: animated)
     self.button.backgroundColor = UIColor.blackColor()
 }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者就干脆把 &lt;code&gt;selectionStyle&lt;/code&gt; 改成 &lt;code&gt;UITableViewCellSelectionStyle.None&lt;/code&gt; 吧。&lt;/p&gt;

&lt;p&gt;我印象中还有一些奇怪的坑在这个 UITableView 中，只是一时想不起来了...&lt;/p&gt;
</content>
    <link href="http://codingnext.com/uitableview.html" rel="alternate"/>
    <published>2016-03-12T00:00:00+08:00</published>
  </entry>
  <entry>
    <id>awsqilitedb.html</id>
    <title>AWSQLiteDB</title>
    <updated>2017-11-16T02:29:15.673700+00:00</updated>
    <author>
      <name>adow</name>
      <email>reynoldqin@gmail.com</email>
    </author>
    <content type="html">&lt;p&gt;AWSQLiteDB a simple wrapper for libsqlite3.0 in Swift&lt;/p&gt;

&lt;p&gt;项目地址: &lt;a href="https://github.com/adow/AWSQLiteDB" title=""&gt;AWSQLiteDB&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;&lt;h3&gt;Carthage&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Carthage&lt;/code&gt; 是一个去中心化的包管理工具。&lt;/p&gt;

&lt;p&gt;安装 Carthage&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew update
$ brew install carthage&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;集成 AWSQLiteDB 到 iOS 项目&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在项目中创建 &lt;code&gt;Cartfile&lt;/code&gt; 文件，并添加下面内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git "https://github.com/adow/AWSQLiteDB.git" &amp;gt;= 0.1.2&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行 &lt;code&gt;Carthage update&lt;/code&gt;, 获取 AWSQLiteDB;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;拖动 &lt;code&gt;Carthage/Build/iOS&lt;/code&gt; 下面的 &lt;code&gt;AWSQLiteDB.framwork&lt;/code&gt; 到项目 &lt;code&gt;Targets&lt;/code&gt;, &lt;code&gt;General&lt;/code&gt; 设置标签的 &lt;code&gt;Linked Frameworks and Linraries&lt;/code&gt; 中；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 &lt;code&gt;Targes&lt;/code&gt; 的 &lt;code&gt;Build Phases&lt;/code&gt; 设置中，点击 &lt;code&gt;+&lt;/code&gt; 按钮，添加 &lt;code&gt;New Run Script Phase&lt;/code&gt; 来添加脚本:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/bin/carthage copy-frameworks&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时在下面的 &lt;code&gt;Input Files&lt;/code&gt; 中添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(SRCROOT)/Carthage/Build/iOS/AWSQLiteDB.framework&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Cocoapods&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!

pod 'AWSQLiteDB', '~&amp;gt; 0.1.2'&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;手动安装&lt;/h3&gt;&lt;h4&gt;通过 Git Submodule 集成&lt;/h4&gt;
&lt;p&gt;通过 Submodule 将 SecrecySwift 作为 Embedded Framework 添加到项目中。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先确保项目已经在 git 仓库中;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加 &lt;code&gt;AWSQLiteDB&lt;/code&gt; 作为 Submodule:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git submodule add https://github.com/adow/AWSQLiteDB.git&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 Xcode 中打开项目，将 AWSQLiteDB.xcodeproj 拖放到你的项目的根目录下;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在你的项目下，选择 &lt;code&gt;Targets&lt;/code&gt; , &lt;code&gt;General&lt;/code&gt; 中添加 &lt;code&gt;Embedded Binaries&lt;/code&gt;, 选择 &lt;code&gt;AWSQLiteDB.framework&lt;/code&gt;, 确保 &lt;code&gt;Build Phases&lt;/code&gt; 中的 &lt;code&gt;Link Binary with Libraries&lt;/code&gt; 中有 &lt;code&gt;AWSQLiteDB.framework&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;或者直接使用 AWSQLiteDB.swift&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;复制 AWSQLiteDB.swift 到项目中&lt;/li&gt;
&lt;li&gt;在项目的 &lt;code&gt;Targets&lt;/code&gt; 的 &lt;code&gt;Build Phases&lt;/code&gt; 的 &lt;code&gt;Link Binary with Libraries&lt;/code&gt; 中添加 &lt;code&gt;libsqlite3.0.tbd&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;使用&lt;/h2&gt;&lt;h3&gt;打开数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;let cache_dir = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory, NSSearchPathDomainMask.UserDomainMask, true)[0]
let db_filename = "\(cache_dir)/sql.db"
let db = SQLiteDB(path: db_filename)&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;关闭数据库&lt;/h3&gt;
&lt;p&gt;SQLiteDB 实例被释放的时候会自动关闭数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.close()&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;打开单例的数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;let cache_dir = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory, NSSearchPathDomainMask.UserDomainMask, true)[0]
let db_filename = "\(cache_dir)/sql.db"
guard let _ = try? SQLiteDB.setupSharedDBPath(db_filename) else {
    return
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;执行 Execute&lt;/h3&gt;
&lt;p&gt;创建表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var sql = "create table test (id INTEGER PRIMARY KEY AUTOINCREMENT, name CHAR(32) NOT NULL)"
print("create table:\(SQLiteDB.sharedDB.execute(sql))")&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Insert&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sql = "insert into test (id,name) values (?,?)"
var result = SQLiteDB.sharedDB.execute(sql, parameters:9, "adow")
print("insert:\(result)")&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;update&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sql = "update test set name=? where id =?"
result = SQLiteDB.sharedDB.execute(sql, parameters: "reynold qin",9)
print("update:\(result)")&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查询 Query&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sql = "select * from test"
let rows = SQLiteDB.sharedDB.query(sql)
for r in rows {
    let id = r["id"]!.value!.integer!
    let name = r["name"]!.value!.string!
    print("\(id):\(name)")
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/24102775/accessing-an-sqlite-database-in-swift" title=""&gt;Accessing an SQLite Database in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/u012485637/article/details/44486923" title=""&gt; SQLite3 C/C++ 开发接口简介（API函数）一、二、三&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.runoob.com/sqlite/sqlite-c-cpp.html" title=""&gt;SQLite - C/C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    <link href="http://codingnext.com/awsqilitedb.html" rel="alternate"/>
    <published>2016-03-08T00:00:00+08:00</published>
  </entry>
  <entry>
    <id>about.html</id>
    <title>关于我</title>
    <updated>2017-11-16T02:29:15.674407+00:00</updated>
    <author>
      <name>adow</name>
      <email>reynoldqin@gmail.com</email>
    </author>
    <content type="html">&lt;p&gt;我是 adow,  一名程序开发者，现在生活在无锡。&lt;/p&gt;

&lt;p&gt;现在，大部分时间我都在开发 iOS App, 从 2015 年开始，我已经将开发语言切换到 Swift，并应用在之后的所有项目中。在其他时候，我也使用 Python 写一些小程序，比如这个博客的程序 &lt;code&gt;ming.py&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以下是我在一些社交网络中的链接:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="[PROJECT]	https://github.com/adow" title=""&gt;github.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="[PROJECT]	https://twitter.com/reynoldqin" title=""&gt;twitter.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="[PROJECT]	https://v2ex.com/member/adow" title=""&gt;v2ex.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    <link href="http://codingnext.com/about.html" rel="alternate"/>
    <published>2016-03-01T00:00:00+08:00</published>
  </entry>
  <entry>
    <id>secrecy-swift.html</id>
    <title>SecrecySwift</title>
    <updated>2017-11-16T02:29:15.674748+00:00</updated>
    <author>
      <name>adow</name>
      <email>reynoldqin@gmail.com</email>
    </author>
    <content type="html">&lt;p&gt;项目地址: &lt;a href="https://github.com/adow/SecrecySwift" title=""&gt;SecrecySwift&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SecrecySwift ，通过包装 &lt;code&gt;CommonCrypto&lt;/code&gt; 和 &lt;code&gt;Security.framework&lt;/code&gt;,实现 Swift 下的摘要方法/AES/RSA加密和签名。&lt;/p&gt;
&lt;h2&gt;特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;摘要算法 (Digest/HMAC): &lt;code&gt;MD2&lt;/code&gt;/&lt;code&gt;MD4&lt;/code&gt;/&lt;code&gt;MD5&lt;/code&gt;/&lt;code&gt;SHA1&lt;/code&gt;/&lt;code&gt;SHA224&lt;/code&gt;/&lt;code&gt;SHA384&lt;/code&gt;/&lt;code&gt;SHA512&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;AES 加密和解密: &lt;code&gt;EBC&lt;/code&gt;/&lt;code&gt;CBC&lt;/code&gt; 模式；&lt;/li&gt;
&lt;li&gt;RSA 加密/解密以及签名和验证算法: &lt;code&gt;MD2&lt;/code&gt;/&lt;code&gt;MD5&lt;/code&gt;/&lt;code&gt;SHA1&lt;/code&gt;/&lt;code&gt;SHA224&lt;/code&gt;/&lt;code&gt;SHA384&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;安装&lt;/h2&gt;&lt;h3&gt;使用 Carthage 安装&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Carthage&lt;/code&gt; 是一个去中心化的包管理工具。&lt;/p&gt;

&lt;p&gt;安装 Carthage&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew update
$ brew install carthage&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;集成 SecrecySwift 到 iOS 项目&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在项目中创建 &lt;code&gt;Cartfile&lt;/code&gt; 文件，并添加下面内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git "https://github.com/adow/SecrecySwift.git" &amp;gt;= 0.3.3&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行 &lt;code&gt;Carthage update&lt;/code&gt;, 获取 SecrecySwift;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;拖动 &lt;code&gt;Carthage/Build/iOS&lt;/code&gt; 下面的 &lt;code&gt;Secrecy.framwork&lt;/code&gt; 到项目 &lt;code&gt;Targets&lt;/code&gt;, &lt;code&gt;General&lt;/code&gt; 设置标签的 &lt;code&gt;Linked Frameworks and Linraries&lt;/code&gt; 中；&lt;/p&gt;

&lt;p&gt;&lt;img src="http://7vihfk.com1.z0.glb.clouddn.com/secrecy-1-800.jpg" alt="secrecy-1"&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 &lt;code&gt;Targes&lt;/code&gt; 的 &lt;code&gt;Build Phases&lt;/code&gt; 设置中，点击 &lt;code&gt;+&lt;/code&gt; 按钮，添加 &lt;code&gt;New Run Script Phase&lt;/code&gt; 来添加脚本:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/bin/carthage copy-frameworks&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时在下面的 &lt;code&gt;Input Files&lt;/code&gt; 中添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(SRCROOT)/Carthage/Build/iOS/Secrecy.framework&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://7vihfk.com1.z0.glb.clouddn.com/secrecy-2-800.jpg" alt="secrecy-2"&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;手动安装&lt;/h3&gt;&lt;h4&gt;通过 Git Submodule&lt;/h4&gt;
&lt;p&gt;通过 Submodule 将 SecrecySwift 作为 Embedded Framework 添加到项目中。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先确保项目已经在 git 仓库中;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加 &lt;code&gt;SecrecySwift&lt;/code&gt; 作为 Submodule:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git submodule add https://github.com/adow/SecrecySwift.git&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 Xcode 中打开项目，将 SecrecySwift.xcodeproj 拖放到你的项目的根目录下;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在你的项目下，选择 &lt;code&gt;Targets&lt;/code&gt; , &lt;code&gt;General&lt;/code&gt; 中添加 &lt;code&gt;Embedded Binaries&lt;/code&gt;, 选择 &lt;code&gt;Secrecy.framework&lt;/code&gt;, 确保 &lt;code&gt;Build Phases&lt;/code&gt; 中的 &lt;code&gt;Link Binary with Libraries&lt;/code&gt; 中有 &lt;code&gt;Secrecy.framework&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;项目中直接部署源代码 (兼容iOS7)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;复制 &lt;code&gt;SecrecySwift&lt;/code&gt; 目录下的这些文件到项目中&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;* AES.swift
* Digest.swift
* HMAC.swift
* RSA.swift
* SecrecyExtension.swift&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在项目根目录下建立一个 CommonCrypto, 并建立一个 module.map 文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module CommonCrypto [system] {
    header "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/include/CommonCrypto/CommonCrypto.h"
    link "CommonCrypto"
    export *
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在项目 Targets 的 &lt;code&gt;Build Settings&lt;/code&gt; 中添加 &lt;code&gt;Import Paths&lt;/code&gt; 中添加 &lt;code&gt;CommonCrypto&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 &lt;code&gt;Targets&lt;/code&gt; 中 &lt;code&gt;Build Phases&lt;/code&gt; 的 &lt;code&gt;Link Binary with Libraries&lt;/code&gt; 中添加 &lt;code&gt;Security.framework&lt;/code&gt; 和 &lt;code&gt;SystemConfiguration.framework&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样就不需要 &lt;code&gt;import Secrecy&lt;/code&gt;, 直接使用里面的函数了；&lt;/p&gt;
&lt;h3&gt;为什么没有 Cocoapods&lt;/h3&gt;
&lt;p&gt;我尝试了好多次使用 &lt;code&gt;Cocoapods&lt;/code&gt; 发布，但是实在没有制作 Cocoapods 的经验，好像是由于需要链接 &lt;code&gt;CommonCrypto&lt;/code&gt; 的缘故，我参考了很多人写的 podspec 文件，仍然无法正确的链接 &lt;code&gt;CommonCrypto&lt;/code&gt;, &lt;code&gt;pod lib lint&lt;/code&gt; 一直都失败。如果您知道如何正确的为这个项目写一个 &lt;code&gt;podspec&lt;/code&gt;,请一定要发一个 Pull Request 给我。&lt;/p&gt;
&lt;h2&gt;使用&lt;/h2&gt;&lt;h3&gt;摘要和 HMAC&lt;/h3&gt;
&lt;p&gt;只要方法来自 SwiftSSL 项目: &lt;a href="https://github.com/SwiftP2P/SwiftSSL" title=""&gt;https://github.com/SwiftP2P/SwiftSSL&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;支持以下的摘要方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MD2；&lt;/li&gt;
&lt;li&gt;MD4；&lt;/li&gt;
&lt;li&gt;MD5；&lt;/li&gt;
&lt;li&gt;SHA1;&lt;/li&gt;
&lt;li&gt;SHA224；&lt;/li&gt;
&lt;li&gt;SHA256；&lt;/li&gt;
&lt;li&gt;SHA384；&lt;/li&gt;
&lt;li&gt;SHA512；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;摘要方法:&lt;/h4&gt;
&lt;p&gt;NSData/String 的 &lt;code&gt;digestHex/digestBase64&lt;/code&gt; 支持将摘要输出为 hex 和 base64 字符串;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let raw = "abc123"
    print(raw.digestHex(DigestAlgorithm.MD5))
    print(raw.digestBase64(DigestAlgorithm.MD5))&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HMAC 签名方法&lt;/h4&gt;
&lt;p&gt;NSData/String 的 &lt;code&gt;signHex/signBase64&lt;/code&gt; 方法支持签名输出为 hex 和 base64 字符串;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let raw = "abc123"
    print(raw.signHex(HMACAlgorithm.SHA1, key: "abc"))
    print(raw.signBase64(HMACAlgorithm.SHA1, key: "abc"))
    print(raw.signBase64(HMACAlgorithm.SHA1, key: "你好"))&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;AES&lt;/h3&gt;
&lt;p&gt;支持 AES 模式 :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;EBC;&lt;/li&gt;
&lt;li&gt;CBC: &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;** 只支持 PKCSPaddding7 的补齐方式；** &lt;/p&gt;

&lt;p&gt;根据提供的 Key 的长度，支持以下的加密方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AES128: 16位&lt;/li&gt;
&lt;li&gt;AES192: 24位;&lt;/li&gt;
&lt;li&gt;AES256: 32位;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;EBC 模式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aesEBCEncrypt&lt;/code&gt; 进行EBC模式加密，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aesEBCDecryptFromHex&lt;/code&gt; 从 hex 字符串进行EBC模式解密&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aesEBCDecryptBase64&lt;/code&gt; 从 base64 字符串进行EBC解密&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let key = "0000000000000000"
    let raw = "0123456789abcdef"
    let encrypt_1 = raw.aesEBCEncrypt(key)
    print(encrypt_1!.hexString)
    print(encrypt_1!.hexString.aesEBCDecryptFromHex(key))
    print(encrypt_1!.base64String)
    print(encrypt_1!.base64String.aesEBCDecryptFromBase64(key))&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;CBC 模式&lt;/h4&gt;
&lt;p&gt;CBC 模式可以指定 IV,如果不指定 IV 的话将用 0 填充;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aesCBCEncrypt&lt;/code&gt; 进行加密;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aecCBCDecryptFromHex&lt;/code&gt; 从 hex 字符串进行解密&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aesCBCDecryptFromBase64&lt;/code&gt; 从 base64 字符串进行解密&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例:     &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let iv = "0000000000000000"
    let encrypt = raw.aesCBCEncrypt(key,iv: iv)
    print(encrypt!.hexString)
    print(encrypt!.hexString.aesCBCDecryptFromHex(key,iv: iv))
    print(encrypt!.base64String)
    print(encrypt!.base64String.aesCBCDecryptFromBase64(key,iv: iv))&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;RSA&lt;/h3&gt;
&lt;p&gt;** 只支持 &lt;code&gt;.der&lt;/code&gt; 文件格式的公钥和 &lt;code&gt;.p12&lt;/code&gt; 格式的私钥 (而 PHP/Java/Python 这些平台使用 pem 文件)；只支持 PKCS1Padding 的补齐；**&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;OpenSSL&lt;/code&gt; 生成各个证书的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 生成 RSA 私钥
openssl genrsa  -out private.pem  2048

# 从密钥中提取公钥
openssl rsa  -pubout  -in private.pem  -out public.pem

# 用私钥生成证书签名请求
openssl req -new -key private.pem -out cert.csr

# 用私钥和证书签名请求生成自签名的证书
openssl x509 -req -days 3650 -in cert.csr -signkey private.pem -out cert.crt

# 将自签名的证书转换为 DER 格式（里面包含公钥）
openssl x509 -outform der -in cert.crt -out cert.der

# 将私钥和证书导出到 p12 文件中（要求输入密码）
openssl pkcs12 -export -inkey private.pem -in cert.crt -out cert.p12&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;加密和解密&lt;/h4&gt;
&lt;p&gt;使用公钥进行加密&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public func encrypt(data:NSData) -&gt; NSData?&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用私钥进行解密 &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public func decrypt(data:NSData) -&gt; NSData?&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public func decrypt(fromHexString hexString:String) -&gt; NSData?&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public func decrypt(fromBase64String base64String:String) -&gt; NSData?&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let path_public = NSBundle.mainBundle().pathForResource("cert", ofType: "der")!
    let path_private = NSBundle.mainBundle().pathForResource("cert", ofType: "p12")!
    let raw = "0123456789abcdefg"
    let raw_data = raw.dataUsingEncoding(NSUTF8StringEncoding)!
    let rsa = RSA(filenameOfPulbicKey: path_public, filenameOfPrivateKey: path_private)
    guard let _rsa = rsa else {
        return
    }
    let encrypt_data = _rsa.encrypt(raw_data)
    let base64_string = encrypt_data!.base64String
    print(base64_string)
    let old_data = _rsa.decrypt(fromBase64String: base64_string)
    let old_string = String(data: old_data!, encoding: NSUTF8StringEncoding)
    print("old_string:\(old_string)")&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;签名和验证&lt;/h3&gt;
&lt;p&gt;支持签名时的摘要算法:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MD2;&lt;/li&gt;
&lt;li&gt;MD5;&lt;/li&gt;
&lt;li&gt;SHA1;&lt;/li&gt;
&lt;li&gt;SHA224;&lt;/li&gt;
&lt;li&gt;SHA256;&lt;/li&gt;
&lt;li&gt;SHA384；&lt;/li&gt;
&lt;li&gt;SHA512；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用私钥签名方法:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public func sign(algorithm:RSAAlgorithm,inputData:NSData) -&gt; NSData?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用公钥的验证方法:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public func verify(algorithm:RSAAlgorithm,inputData:NSData, signedData:NSData) -&gt; Bool&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let path_public = NSBundle.mainBundle().pathForResource("cert", ofType: "der")!
            let path_private = NSBundle.mainBundle().pathForResource("cert", ofType: "p12")!

    let rsa = RSA(filenameOfPulbicKey: path_public, filenameOfPrivateKey: path_private)
    guard let _rsa = rsa else {
        return
    }

    let raw = "0123456789abcdefg"
    let raw_data = raw.dataUsingEncoding(NSUTF8StringEncoding)!
    let sign_data = _rsa.sign(RSAAlgorithm.SHA1,inputData:raw_data)
    //        print(sign_data!.hexString)
    print(sign_data!.base64String)

    let raw_test = "0123456789abcdefg"
    let raw_test_data = raw_test.dataUsingEncoding(NSUTF8StringEncoding)!
    let verified = _rsa.verify(RSAAlgorithm.SHA1,inputData: raw_test_data, signedData: sign_data!)
    print("\(verified)")&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;扩展 NSData&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hexString&lt;/code&gt;: 输出 hex 字符串;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;base64String&lt;/code&gt;: 输出 base64 字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arrayOfBytes&lt;/code&gt;: 输出 &lt;code&gt;[UInt8]&lt;/code&gt; 数组;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension NSData {
        public var hexString : String
        public var base64String:String
        public func arrayOfBytes() -&amp;gt; [UInt8]
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;扩展 String&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dataFromHexadecimalString&lt;/code&gt;: 从 hex 字符串转换到 NSData;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extenstion String {
        func dataFromHexadecimalString() -&amp;gt; NSData?
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如何在 Python 中验证和 SecrecySwift 相同功能的示例 &lt;a href="https://github.com/adow/SecrecySwift/blob/master/SecrecTestPy/test.py" title=""&gt;SecrecyTestPy/test.py&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.jianshu.com/p/98610bdc9bd6" title=""&gt;【加密解密】加密解密介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://kvmisc.github.io/blog/2015/02/10/implement-aes-and-rsa-algorithm-in-ios/" title=""&gt;iOS 系统中 AES 和 RSA 算法的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/adow/SecrecySwift/blob/master/SecrecySwift/AES.swift" title=""&gt;AES.swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://kvmisc.github.io/blog/2015/02/10/implement-aes-and-rsa-algorithm-in-ios/" title=""&gt;iOS 系统中 AES 和 RSA 算法的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.cnbluebox.com/blog/2014/03/19/rsajia-mi/" title=""&gt;RSA加密&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/adow/SecrecySwift/blob/master/SecrecySwift/RSA.swift" title=""&gt;RSA.swift&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    <link href="http://codingnext.com/secrecy-swift.html" rel="alternate"/>
    <published>2016-02-29T00:00:00+08:00</published>
  </entry>
</feed>
